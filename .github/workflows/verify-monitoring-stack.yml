name: 'Verify Monitoring Stack - Full Health Check'

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to verify'
        required: true
        type: choice
        options:
          - dev
          - prod

jobs:
  verify-monitoring-stack:
    name: Verify Complete Monitoring Stack
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H github.com >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Install hcloud CLI
        run: |
          curl -fsSL https://github.com/hetznercloud/cli/releases/download/v1.47.0/hcloud-linux-amd64.tar.gz | tar -xz
          chmod +x hcloud
          sudo mv hcloud /usr/local/bin/
          hcloud version

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Get Control Plane IP from Hetzner Cloud
        id: control_ip
        env:
          HCLOUD_TOKEN: ${{ secrets.HCLOUD_TOKEN }}
        run: |
          ENV="${{ inputs.environment }}"
          CLUSTER="k3s-trading"
          
          echo "ğŸ“¡ Fetching control plane IP from Hetzner Cloud..."
          # Query by server name pattern: {env}-{cluster}-control
          CONTROL_NAME="${ENV}-${CLUSTER}-control"
          echo "   Looking for server: $CONTROL_NAME"
          
          CONTROL_IP=$(hcloud server list -o noheader -o columns=name,ipv4 | grep "^$CONTROL_NAME " | awk '{print $2}' | head -1)
          
          if [ -z "$CONTROL_IP" ]; then
            echo "âŒ Could not find control plane server '$CONTROL_NAME' in Hetzner Cloud"
            echo ""
            echo "Available servers:"
            hcloud server list -o noheader -o columns=name,ipv4
            exit 1
          fi
          
          echo "ip=$CONTROL_IP" >> $GITHUB_OUTPUT
          echo "âœ… Found control plane IP: $CONTROL_IP"

      - name: Download Kubeconfig
        run: |
          CONTROL_IP="${{ steps.control_ip.outputs.ip }}"
          mkdir -p ~/.kube
          
          echo "ğŸ“¥ Downloading kubeconfig from $CONTROL_IP..."
          for i in {1..5}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$CONTROL_IP "cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config 2>/dev/null; then
              sed -i "s/127.0.0.1/$CONTROL_IP/g" ~/.kube/config
              chmod 600 ~/.kube/config
              echo "âœ… Kubeconfig downloaded"
              break
            fi
            echo "âš ï¸  Retry $i/5..."
            sleep 5
          done

      - name: Verify Kubernetes Cluster
        run: |
          echo "ğŸ” Checking Kubernetes cluster..."
          kubectl cluster-info || exit 1
          kubectl get nodes -o wide
          echo "âœ… Kubernetes cluster is accessible"

      - name: Verify ArgoCD Deployment
        id: argocd_check
        continue-on-error: true
        run: |
          echo "ğŸ” Checking ArgoCD..."
          kubectl get deployment -n argocd argocd-server -o wide
          
          if kubectl wait --for=condition=Available deployment/argocd-server -n argocd --timeout=30s 2>/dev/null; then
            echo "âœ… ArgoCD deployment is ready"
            ARGOCD_READY=true
          else
            echo "âš ï¸  ArgoCD deployment not ready yet"
            ARGOCD_READY=false
          fi
          echo "ready=$ARGOCD_READY" >> $GITHUB_OUTPUT

      - name: Verify ArgoCD Applications Status
        continue-on-error: true
        run: |
          echo "ğŸ“‹ Checking ArgoCD Applications..."
          
          APPS=("monitoring" "kafka" "ingestion")
          for app in "${APPS[@]}"; do
            echo ""
            echo "Checking Application: $app"
            STATUS=$(kubectl get application $app -n argocd -o jsonpath='{.status.operationState.phase}' 2>/dev/null || echo "NOT_FOUND")
            SYNC=$(kubectl get application $app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "UNKNOWN")
            
            if [ "$SYNC" == "Synced" ]; then
              echo "âœ… $app: Synced"
            else
              echo "â³ $app: Sync status = $SYNC"
            fi
          done

      - name: Verify Prometheus Operator & Instance
        id: prometheus_check
        run: |
          echo "ğŸ” Checking Prometheus..."
          
          # Check Prometheus operator
          if kubectl get pod -n monitoring -l "app=kube-prometheus-stack-operator" -o wide; then
            echo "âœ… Prometheus Operator is running"
          else
            echo "âŒ Prometheus Operator not found"
            exit 1
          fi
          
          # Wait for Prometheus instance
          echo "â³ Waiting for Prometheus instance..."
          if kubectl wait --for=condition=Ready pod -l "app.kubernetes.io/name=prometheus" -n monitoring --timeout=120s 2>/dev/null; then
            echo "âœ… Prometheus instance is ready"
            PROMETHEUS_READY=true
          else
            echo "âš ï¸  Prometheus instance not ready yet"
            PROMETHEUS_READY=false
          fi
          echo "ready=$PROMETHEUS_READY" >> $GITHUB_OUTPUT
          
          # Check Prometheus service
          PROM_IP=$(kubectl get svc prometheus-operated -n monitoring -o jsonpath='{.spec.clusterIP}' 2>/dev/null)
          if [ -n "$PROM_IP" ]; then
            echo "âœ… Prometheus service IP: $PROM_IP:9090"
          fi

      - name: Verify Grafana Operator & Instance
        id: grafana_check
        continue-on-error: true
        run: |
          echo "ğŸ” Checking Grafana..."
          
          # Check Grafana operator
          if kubectl get pod -n monitoring -l "app.kubernetes.io/name=grafana-operator" -o wide; then
            echo "âœ… Grafana Operator is running"
          else
            echo "âš ï¸  Grafana Operator not found (may not be deployed yet)"
          fi
          
          # Debug: Show all pods with grafana labels
          echo "ğŸ“‹ Grafana-related pods in monitoring namespace:"
          kubectl get pods -n monitoring -o wide | grep -i grafana || echo "   No grafana pods found"
          
          # Wait for Grafana instance - Grafana Operator creates pods with app=<cr-name>-grafana
          # For Grafana CR named "main", the deployment is "main-deployment" with app=main-grafana
          echo "â³ Waiting for Grafana instance (CR: main)..."
          if kubectl wait --for=condition=Ready pod -l "app=main-grafana" -n monitoring --timeout=120s 2>/dev/null; then
            echo "âœ… Grafana instance is ready"
            GRAFANA_READY=true
          else
            echo "âš ï¸  Grafana instance not ready yet"
            echo "   Available deployments:"
            kubectl get deployments -n monitoring | grep -i grafana || echo "   No grafana deployments"
            GRAFANA_READY=false
          fi
          echo "ready=$GRAFANA_READY" >> $GITHUB_OUTPUT
          
          # Check Grafana service - Grafana Operator creates <cr-name>-service
          GRAFANA_IP=$(kubectl get svc main-service -n monitoring -o jsonpath='{.spec.clusterIP}' 2>/dev/null)
          if [ -n "$GRAFANA_IP" ]; then
            echo "âœ… Grafana service IP: $GRAFANA_IP:3000"
          else
            echo "   Grafana services:"
            kubectl get svc -n monitoring | grep -i grafana || echo "   No grafana services"
          fi

      - name: Verify ServiceMonitors
        id: servicemonitor_check
        continue-on-error: true
        run: |
          echo "ğŸ” Checking ServiceMonitors..."
          
          MONITORS=("kafka-broker" "kube-state-metrics" "node-exporter")
          for monitor in "${MONITORS[@]}"; do
            if kubectl get servicemonitor $monitor -n monitoring &>/dev/null; then
              TARGET_COUNT=$(kubectl get servicemonitor $monitor -n monitoring -o jsonpath='{.spec.selector.matchLabels}' | grep -o 'app' | wc -l)
              echo "âœ… ServiceMonitor '$monitor' exists (targets configured)"
            else
              echo "âš ï¸  ServiceMonitor '$monitor' not found"
            fi
          done

      - name: Verify Grafana Datasources
        id: datasource_check
        continue-on-error: true
        run: |
          echo "ğŸ” Checking Grafana Datasources..."
          
          if kubectl get grafanadatasource prometheus -n monitoring &>/dev/null; then
            echo "âœ… GrafanaDatasource 'prometheus' configured"
            DATASOURCE_URL=$(kubectl get grafanadatasource prometheus -n monitoring -o jsonpath='{.spec.datasourceSpec.url}')
            echo "   URL: $DATASOURCE_URL"
          else
            echo "âš ï¸  GrafanaDatasource 'prometheus' not found"
          fi

      - name: Verify Grafana Dashboards
        id: dashboard_check
        continue-on-error: true
        run: |
          echo "ğŸ” Checking Grafana Dashboards..."
          
          DASHBOARDS=("kafka-broker" "k3s-cluster-health")
          for dashboard in "${DASHBOARDS[@]}"; do
            if kubectl get grafanadashboard $dashboard -n monitoring &>/dev/null; then
              UID=$(kubectl get grafanadashboard $dashboard -n monitoring -o jsonpath='{.spec.dashboard.uid}')
              TITLE=$(kubectl get grafanadashboard $dashboard -n monitoring -o jsonpath='{.spec.dashboard.title}')
              echo "âœ… Dashboard '$dashboard': $TITLE (UID: $UID)"
            else
              echo "âš ï¸  Dashboard '$dashboard' not found"
            fi
          done

      - name: Verify Kafka Metrics
        id: kafka_check
        continue-on-error: true
        run: |
          echo "ğŸ” Checking Kafka..."
          
          # Check Kafka broker pods
          KAFKA_PODS=$(kubectl get pods -n kafka -l "app.kubernetes.io/name=kafka" -o wide)
          if [ -n "$KAFKA_PODS" ]; then
            echo "âœ… Kafka brokers running:"
            echo "$KAFKA_PODS"
          else
            echo "âš ï¸  No Kafka brokers found"
          fi
          
          # Check for Kafka JMX metrics port
          if kubectl get svc -n kafka | grep -i kafka &>/dev/null; then
            echo "âœ… Kafka services exist"
          fi

      - name: Verify Prometheus Targets (if ready)
        id: prometheus_targets
        if: ${{ steps.prometheus_check.outputs.ready == 'true' }}
        continue-on-error: true
        run: |
          echo "ğŸ” Checking Prometheus targets..."
          
          # Port-forward to Prometheus
          kubectl port-forward -n monitoring svc/prometheus-operated 9090:9090 &
          sleep 3
          
          # Query targets
          TARGETS=$(curl -s http://localhost:9090/api/v1/targets | jq '.data.activeTargets | length')
          if [ "$TARGETS" -gt 0 ]; then
            echo "âœ… Prometheus has $TARGETS active targets"
            curl -s http://localhost:9090/api/v1/targets | jq '.data.activeTargets[] | {job: .labels.job, instance: .labels.instance}' | head -20
          else
            echo "âš ï¸  No active targets in Prometheus yet (data may be loading)"
          fi
          
          pkill -f "port-forward" || true

      - name: Verify Grafana Connectivity (if ready)
        id: grafana_connectivity
        if: ${{ steps.grafana_check.outputs.ready == 'true' }}
        continue-on-error: true
        run: |
          echo "ğŸ” Checking Grafana connectivity from external host..."
          
          CONTROL_IP="${{ steps.control_ip.outputs.ip }}"
          
          # Method 1: Port-forward via SSH (remote port-forward)
          echo "ğŸ“¡ Setting up SSH port-forward to Grafana..."
          ssh -o StrictHostKeyChecking=no -N -L 3000:127.0.0.1:3000 root@$CONTROL_IP &
          PF_PID=$!
          sleep 3
          
          # Method 2: Check if Grafana is accessible via port-forward
          echo "ğŸŒ Testing Grafana HTTP health check..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -k http://localhost:3000/api/health 2>/dev/null || echo "000")
          
          if [ "$HTTP_STATUS" == "200" ]; then
            echo "âœ… Grafana HTTP API is healthy (status: $HTTP_STATUS)"
          else
            echo "âš ï¸  Grafana HTTP returned status: $HTTP_STATUS"
          fi
          
          # Method 3: Test Grafana login
          echo "ğŸ” Testing Grafana login..."
          LOGIN_RESPONSE=$(curl -s -X POST http://localhost:3000/api/auth/login \
            -H "Content-Type: application/json" \
            -d '{"user":"admin","password":"admin-dev-123"}' 2>/dev/null)
          
          TOKEN=$(echo "$LOGIN_RESPONSE" | jq -r '.token' 2>/dev/null)
          
          if [ "$TOKEN" != "null" ] && [ -n "$TOKEN" ]; then
            echo "âœ… Grafana login successful!"
            echo "   Token: ${TOKEN:0:20}..."
            LOGIN_SUCCESS=true
          else
            echo "âŒ Grafana login failed"
            echo "   Response: $LOGIN_RESPONSE"
            LOGIN_SUCCESS=false
          fi
          echo "login_success=$LOGIN_SUCCESS" >> $GITHUB_OUTPUT
          
          # Method 4: Check datasources (requires auth)
          if [ "$LOGIN_SUCCESS" == "true" ]; then
            echo ""
            echo "ğŸ“Š Checking Grafana datasources..."
            DATASOURCES=$(curl -s -H "Authorization: Bearer $TOKEN" http://localhost:3000/api/datasources)
            DATASOURCE_COUNT=$(echo "$DATASOURCES" | jq 'length' 2>/dev/null || echo "0")
            
            if [ "$DATASOURCE_COUNT" -gt 0 ]; then
              echo "âœ… Grafana has $DATASOURCE_COUNT datasource(s):"
              echo "$DATASOURCES" | jq '.[] | {name: .name, type: .type, url: .url}' | head -20
            else
              echo "âš ï¸  No datasources found in Grafana"
            fi
            
            # Check dashboards
            echo ""
            echo "ğŸ“ˆ Checking Grafana dashboards..."
            DASHBOARDS=$(curl -s -H "Authorization: Bearer $TOKEN" http://localhost:3000/api/search)
            DASHBOARD_COUNT=$(echo "$DASHBOARDS" | jq 'length' 2>/dev/null || echo "0")
            
            if [ "$DASHBOARD_COUNT" -gt 0 ]; then
              echo "âœ… Grafana has $DASHBOARD_COUNT dashboard(s):"
              echo "$DASHBOARDS" | jq '.[] | {title: .title, uid: .uid}' | head -20
            else
              echo "âš ï¸  No dashboards found in Grafana"
            fi
          fi
          
          # Cleanup port-forward
          kill $PF_PID 2>/dev/null || true
          sleep 1

      - name: Verify External Grafana Access (alternative method)
        id: grafana_external
        if: ${{ steps.grafana_check.outputs.ready == 'true' }}
        continue-on-error: true
        run: |
          echo "ğŸ” Verifying Grafana Ingress and Traefik routing..."
          
          CONTROL_IP="${{ steps.control_ip.outputs.ip }}"
          
          # Check if Grafana Ingress exists
          echo "ğŸ“‹ Checking Grafana Ingress..."
          if kubectl get ingress -n monitoring grafana -o wide &>/dev/null; then
            echo "âœ… Grafana Ingress exists"
            kubectl get ingress -n monitoring grafana -o wide
            
            INGRESS_NAME=$(kubectl get ingress -n monitoring grafana -o jsonpath='{.metadata.name}' 2>/dev/null)
            INGRESS_CLASS=$(kubectl get ingress -n monitoring grafana -o jsonpath='{.spec.ingressClassName}' 2>/dev/null)
            echo "   Ingress Class: $INGRESS_CLASS"
            
            # Check routing
            echo ""
            echo "ğŸ“¡ Checking Traefik routing for Grafana..."
            TRAEFIK_ROUTES=$(kubectl get ingressroute -n monitoring -o jsonpath='{.items[?(@.spec.routes[*].match)].metadata.name}' 2>/dev/null || echo "N/A")
            if [ -n "$TRAEFIK_ROUTES" ]; then
              echo "âœ… Traefik routes configured: $TRAEFIK_ROUTES"
            fi
          else
            echo "âš ï¸  Grafana Ingress not found"
          fi
          
          # Check Traefik service and ports
          echo ""
          echo "ğŸ”Œ Checking Traefik NodePort configuration..."
          TRAEFIK_PORTS=$(kubectl get svc traefik -n kube-system -o jsonpath='{.spec.ports}' 2>/dev/null)
          if [ -n "$TRAEFIK_PORTS" ]; then
            echo "âœ… Traefik service ports:"
            kubectl get svc traefik -n kube-system -o wide
            
            HTTP_PORT=$(kubectl get svc traefik -n kube-system -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}' 2>/dev/null)
            HTTPS_PORT=$(kubectl get svc traefik -n kube-system -o jsonpath='{.spec.ports[?(@.port==443)].nodePort}' 2>/dev/null)
            
            echo ""
            echo "   HTTP:  port 80  â†’ NodePort :$HTTP_PORT"
            echo "   HTTPS: port 443 â†’ NodePort :$HTTPS_PORT"
          fi
          
          # Check for port collisions - list all Ingress entries
          echo ""
          echo "ğŸ“Š Checking all Ingress resources (potential routing conflicts)..."
          INGRESS_COUNT=$(kubectl get ingress -A -o jsonpath='{.items | length}')
          if [ "$INGRESS_COUNT" -gt 0 ]; then
            echo "   Found $INGRESS_COUNT Ingress resource(s):"
            kubectl get ingress -A -o wide | awk 'NR>1 {print "   " $0}'
          fi

      - name: Generate Summary Report
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘          MONITORING STACK VERIFICATION REPORT                  â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“Š COMPONENT STATUS:"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          
          echo ""
          echo "Kubernetes:"
          kubectl get nodes -o wide | awk '{print "  " $0}'
          
          echo ""
          echo "ArgoCD:"
          if [ "${{ steps.argocd_check.outputs.ready }}" == "true" ]; then
            echo "  âœ… ArgoCD is ready"
          else
            echo "  â³ ArgoCD is deploying"
          fi
          
          echo ""
          echo "Prometheus:"
          if [ "${{ steps.prometheus_check.outputs.ready }}" == "true" ]; then
            echo "  âœ… Prometheus is ready"
            echo "  ğŸ“ˆ Metrics endpoint: http://prometheus-operated.monitoring:9090"
          else
            echo "  â³ Prometheus is starting (wait 1-2 minutes)"
          fi
          
          echo ""
          echo "Grafana:"
          if [ "${{ steps.grafana_check.outputs.ready }}" == "true" ]; then
            echo "  âœ… Grafana instance is ready"
            if [ "${{ steps.grafana_connectivity.outputs.login_success }}" == "true" ]; then
              echo "  âœ… Login test successful"
            else
              echo "  â³ Login test pending or failed"
            fi
            echo ""
            echo "  ğŸŒ Web UI Access (via Traefik):"
            echo "     URL: https://${{ steps.control_ip.outputs.ip }}:30443"
            echo "     (Ignore TLS warnings - self-signed cert)"
            echo ""
            echo "  ğŸ‘¤ Credentials:"
            echo "     User: admin"
            echo "     Password: admin-dev-123 (dev), check prod overlay for prod"
          else
            echo "  â³ Grafana is starting (wait 1-2 minutes)"
          fi
          
          echo ""
          echo "ServiceMonitors:"
          echo "  â€¢ kafka-broker"
          echo "  â€¢ kube-state-metrics"
          echo "  â€¢ node-exporter"
          
          echo ""
          echo "Dashboards:"
          echo "  â€¢ Kafka Broker Metrics (kafka-broker-hello)"
          echo "  â€¢ K3s Cluster Health (k3s-cluster-health)"
          
          echo ""
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "ğŸš€ NEXT STEPS:"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo ""
          if [ "${{ steps.grafana_check.outputs.ready }}" == "true" ]; then
            echo "âœ… Grafana is running via Traefik!"
            echo ""
            echo "ğŸŒ Access Grafana:"
            echo ""
            echo "   URL: https://${{ steps.control_ip.outputs.ip }}:30443"
            echo "   User: admin"
            echo "   Password: admin-dev-123"
            echo ""
            echo "   âš ï¸  Self-signed TLS certificate - accept browser warning"
            echo ""
            echo "ğŸ“Š Available Dashboards:"
            echo "   â€¢ Kafka Broker Metrics"
            echo "   â€¢ K3s Cluster Health"
            echo ""
            echo "ğŸ”Œ Routing:"
            echo "   â€¢ Traefik NodePort HTTPS: :30443"
            echo "   â€¢ Traefik NodePort HTTP:  :30080"
            echo "   â€¢ Ingress Class: traefik"
            echo "   â€¢ No hostname collision (IP-based)"
            echo ""
            echo "â³ Prometheus metrics may take 2-3 minutes to appear"
            echo ""
          else
            echo "1. â³ Wait for Grafana to start (1-2 minutes)"
            echo "2. â³ Rerun this action in 2-3 minutes"
            echo ""
          fi
          
          echo "ğŸ“‹ Verify Traefik routing:"
          echo "   kubectl get ingress -A"
          echo "   kubectl get ingressroute -A"
          echo ""
          echo "ğŸ“Š For detailed troubleshooting:"
          echo "   kubectl get pods -n monitoring -o wide"
          echo "   kubectl logs -n monitoring -l app.kubernetes.io/name=grafana"
          echo ""

      - name: Fail if Critical Components Missing
        if: |
          steps.prometheus_check.outcome == 'failure' ||
          steps.grafana_check.outcome == 'failure'
        run: |
          echo "âŒ Critical monitoring components are not ready"
          echo "Please check:"
          echo "  - ArgoCD is syncing resources"
          echo "  - All pods in 'monitoring' namespace"
          echo "  - Check logs: kubectl logs -n monitoring -l app.kubernetes.io/name=grafana"
          exit 1
