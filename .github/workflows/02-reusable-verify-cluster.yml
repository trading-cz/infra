name: '02 Reusable: Verify K3s Cluster'

on:
  workflow_call:
    inputs:
      control_plane_ip:
        description: 'Control Plane IP'
        required: true
        type: string
    secrets:
      ssh_private_key:
        description: 'SSH private key for server access'
        required: true

jobs:
  verify:
    name: Verify K3s cluster
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ssh_private_key }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Download Kubeconfig from Control Plane
        run: |
          CONTROL_IP="${{ inputs.control_plane_ip }}"
          mkdir -p ~/.kube
          
          echo "üì• Downloading kubeconfig from $CONTROL_IP..."
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$CONTROL_IP "cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config 2>/dev/null; then
            sed -i "s/127.0.0.1/$CONTROL_IP/g" ~/.kube/config
            chmod 600 ~/.kube/config
            echo "‚úÖ Kubeconfig downloaded and configured"
          else
            echo "‚ùå Failed to download kubeconfig"
            exit 1
          fi

      - name: Verify K3s Nodes
        run: |
          kubectl get nodes
          NODE_COUNT=$(kubectl get nodes --no-headers | wc -l)
          # Expect 1 control plane + kafka_node_count (3 for KRaft quorum)
          # Minimum is 4 nodes (1 control + 3 kafka) for production/dev with HA
          if [ "$NODE_COUNT" -ge 4 ]; then
            echo "‚úÖ K3s cluster operational with $NODE_COUNT nodes (1 control + $((NODE_COUNT-1)) kafka)"
          elif [ "$NODE_COUNT" -ge 2 ]; then
            echo "‚ö†Ô∏è K3s cluster has $NODE_COUNT nodes - expected 4+ for HA Kafka"
            echo "   This may be intentional for testing environments"
          else
            echo "‚ùå Expected at least 2 nodes, found $NODE_COUNT"
            exit 1
          fi

      - name: Verify System Pods
        run: |
          echo "Waiting for CoreDNS to be ready..."
          kubectl wait --for=condition=ready pod -l k8s-app=kube-dns -n kube-system --timeout=300s
          COREDNS_COUNT=$(kubectl get pods -n kube-system -l k8s-app=kube-dns --no-headers | grep Running | wc -l)
          if [ "$COREDNS_COUNT" -ge 1 ]; then
            echo "‚úÖ CoreDNS running ($COREDNS_COUNT pods)"
          else
            echo "‚ùå CoreDNS not running"
            exit 1
          fi

      - name: Verify Traefik Ingress Controller
        run: |
          echo "Checking Traefik ingress controller..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=traefik -n kube-system --timeout=300s || true
          TRAEFIK_COUNT=$(kubectl get pods -n kube-system -l app.kubernetes.io/name=traefik --no-headers | grep Running | wc -l)
          if [ "$TRAEFIK_COUNT" -ge 1 ]; then
            echo "‚úÖ Traefik ingress controller running ($TRAEFIK_COUNT pods)"
          else
            echo "‚ö†Ô∏è  Traefik not running - ingress may not work"
          fi
          
          echo ""
          echo "Traefik service:"
          kubectl get svc -n kube-system -l app.kubernetes.io/name=traefik || true

      - name: Debug on Failure
        if: failure()
        run: |
          echo "‚ùå Verification Failed. Dumping Cluster State..."
          echo "::group::Nodes"
          kubectl get nodes -o wide
          kubectl describe nodes
          echo "::endgroup::"
          echo "::group::All Pods"
          kubectl get pods -A -o wide
          echo "::endgroup::"
          echo "::group::Events"
          kubectl get events -A --sort-by='.lastTimestamp'
          echo "::endgroup::"

      - name: Verify Network Ports
        run: |
          if timeout 5 bash -c "cat < /dev/null > /dev/tcp/${{ inputs.control_plane_ip }}/6443" 2>/dev/null; then
            echo "‚úÖ K3s API port 6443 is open"
          else
            echo "‚ùå K3s API port 6443 is not accessible"
            exit 1
          fi

      - name: Label Kafka Nodes
        run: |
          echo "Labeling Kafka nodes for workload placement..."
          for node in $(kubectl get nodes -o name | grep kafka); do
            NODE_NAME=$(echo $node | cut -d'/' -f2)
            kubectl label node "$NODE_NAME" workload=kafka --overwrite
            echo "‚úÖ Labeled $NODE_NAME with workload=kafka"
          done
          echo ""
          echo "Node labels:"
          kubectl get nodes --show-labels
