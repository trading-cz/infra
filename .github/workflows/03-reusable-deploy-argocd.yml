name: 'Reusable: Deploy ArgoCD'

on:
  workflow_call:
    inputs:
      control_plane_ip:
        description: 'Control Plane IP'
        required: true
        type: string
      environment:
        description: 'Deployment environment (dev|prod)'
        required: true
        type: string
    secrets:
      ssh_private_key:
        description: 'SSH private key for server access'
        required: true
      argocd_admin_password:
        description: 'ArgoCD admin password'
        required: false
      token_git_repo_config:
        description: 'Token for config repo'
        required: true

jobs:
  deploy:
    name: Deploy and Verify ArgoCD
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Infra Repository
        uses: actions/checkout@v4
        with:
          path: infra

      - name: Checkout Config Repository
        uses: actions/checkout@v4
        with:
          repository: trading-cz/config
          ref: main
          path: config
          token: ${{ secrets.token_git_repo_config }}

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ssh_private_key }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          echo "‚úÖ SSH key configured"

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          echo "‚úÖ kubectl installed"

      - name: Download Kubeconfig from Control Plane
        run: |
          CONTROL_IP="${{ inputs.control_plane_ip }}"
          
          echo "=========================================="
          echo "Downloading Kubeconfig from Control Plane"
          echo "Control Plane IP: $CONTROL_IP"
          echo "=========================================="
          
          mkdir -p ~/.kube
          
          echo "üì• Fetching kubeconfig via SSH..."
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$CONTROL_IP "cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config 2>/dev/null; then
            echo "‚úÖ Kubeconfig downloaded successfully"
          else
            echo "‚ùå Failed to download kubeconfig from control plane"
            echo "   Verify:"
            echo "   1. Control plane IP is correct: $CONTROL_IP"
            echo "   2. SSH access is working: ssh root@$CONTROL_IP"
            echo "   3. K3s is installed: /etc/rancher/k3s/k3s.yaml exists"
            exit 1
          fi
          
          # Replace localhost with actual control plane IP
          sed -i "s/127.0.0.1/$CONTROL_IP/g" ~/.kube/config
          chmod 600 ~/.kube/config
          
          FILE_SIZE=$(stat -c%s ~/.kube/config)
          echo "‚úÖ Kubeconfig prepared (size: $FILE_SIZE bytes)"
          
          echo ""
          echo "Testing cluster connection..."
          if kubectl cluster-info > /tmp/cluster_info.log 2>&1; then
            echo "‚úÖ Cluster connection successful!"
            cat /tmp/cluster_info.log
          else
            echo "‚ùå Cannot connect to cluster"
            cat /tmp/cluster_info.log
            echo ""
            echo "Kubeconfig content (first 10 lines):"
            head -n 10 ~/.kube/config
            exit 1
          fi
          
          echo ""
          echo "=========================================="

      - name: Install ArgoCD Operator
        env:
          KUBECONFIG: /home/runner/.kube/config
        run: |
          echo "=========================================="
          echo "Installing ArgoCD Operator v0.15.0"
          echo "Method: kubectl apply (manual installation)"
          echo "=========================================="
          
          # Verify kubectl can connect
          echo "Verifying cluster connectivity..."
          kubectl get nodes || {
            echo "ERROR: Cannot connect to Kubernetes cluster"
            echo "KUBECONFIG: $KUBECONFIG"
            exit 1
          }
          
          echo ""
          echo "Current cluster state:"
          echo "Namespaces:"
          kubectl get namespaces
          echo ""
          echo "Existing ArgoCD resources:"
          kubectl get all -n argocd 2>/dev/null || echo "No resources in argocd namespace"
          kubectl get all -n argocd-operator-system 2>/dev/null || echo "No resources in argocd-operator-system namespace"
          echo ""
          
          # Download and extract the operator release
          OPERATOR_VERSION="v0.15.0"
          echo "Downloading ArgoCD Operator ${OPERATOR_VERSION}..."
          curl -sL "https://github.com/argoproj-labs/argocd-operator/archive/refs/tags/${OPERATOR_VERSION}.tar.gz" -o argocd-operator.tar.gz
          
          echo "Extracting archive..."
          tar -xzf argocd-operator.tar.gz
          
          echo ""
          echo "Deploying operator using kustomize..."
          kubectl create namespace argocd 2>/dev/null || echo "Namespace argocd already exists"
          kubectl create namespace argocd-operator-system 2>/dev/null || echo "Namespace argocd-operator-system already exists"
          
          # Use kubectl create instead of apply to avoid CRD annotation size issues
          echo "Installing operator manifests..."
          kubectl kustomize argocd-operator-${OPERATOR_VERSION#v}/config/default | kubectl create -f - || {
            echo "‚ö†Ô∏è  Some resources already exist, updating them..."
            kubectl kustomize argocd-operator-${OPERATOR_VERSION#v}/config/default | kubectl apply -f - --server-side=true --force-conflicts
          }
          
          echo ""
          echo "Waiting for operator to be ready..."
          kubectl wait --for=condition=available --timeout=5m \
            deployment/argocd-operator-controller-manager \
            -n argocd-operator-system || {
              echo "ERROR: Operator deployment failed to become ready"
              echo "Deployment status:"
              kubectl get deployment -n argocd-operator-system
              echo ""
              echo "Pod status:"
              kubectl get pods -n argocd-operator-system
              echo ""
              echo "Pod logs:"
              kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=50
              exit 1
            }
          
          echo ""
          echo "Verifying operator installation..."
          kubectl get pods -n argocd-operator-system
          
          echo ""
          echo "Checking ArgoCD CRDs..."
          kubectl get crd | grep argoproj || {
            echo "WARNING: ArgoCD CRDs not found"
            kubectl get crd
            exit 1
          }
          
          echo ""
          echo "=========================================="
          echo "ArgoCD Operator installed successfully!"
          echo "=========================================="

      - name: Deploy ArgoCD Instance
        run: |
          echo "=========================================="
          echo "Deploying ArgoCD CR from config repository"
          echo "=========================================="
          
          echo "ArgoCD CR file:"
          cat config/base/operators/argocd/argocd.yaml
          echo ""
          
          echo "Applying ArgoCD CR..."
          if ! kubectl apply -k config/base/operators/argocd; then
            echo ""
            echo "‚ùå Failed to deploy ArgoCD CR"
            echo ""
            echo "Debugging information:"
            echo "===================="
            echo "Operator pod status:"
            kubectl get pods -n argocd-operator-system
            echo ""
            echo "Operator logs (last 50 lines):"
            kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=50 || true
            echo ""
            echo "ArgoCD CRD version info:"
            kubectl get crd argocds.argoproj.io -o yaml | grep -A 20 "versions:" || true
            echo ""
            echo "Available API versions for ArgoCD:"
            kubectl api-resources | grep argocd || true
            exit 1
          fi
          
          echo "‚úÖ ArgoCD CR deployed successfully"
          echo ""
          
          # Check ArgoCD CR status immediately
          echo "Checking ArgoCD CR status..."
          kubectl get argocd trading-argocd -n argocd -o yaml || true
          echo ""
          
          echo "Checking operator logs after CR creation..."
          kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=100 || true
          echo ""
          
          echo "Waiting for ArgoCD components to be ready..."
          
          # Wait for ArgoCD server deployment (with retry)
          echo "Waiting for ArgoCD server..."
          for i in {1..24}; do
            if kubectl get deployment trading-argocd-server -n argocd >/dev/null 2>&1; then
              echo "‚úÖ ArgoCD server deployment found"
              break
            fi
            echo "‚è≥ Attempt $i/24: Waiting for ArgoCD server deployment to be created..."
            
            # Show what resources exist
            if [ $((i % 6)) -eq 0 ]; then
              echo "Current resources in argocd namespace:"
              kubectl get all -n argocd || true
              echo ""
              echo "Recent operator logs:"
              kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=20 --since=30s || true
              echo ""
            fi
            
            sleep 5
            
            if [ $i -eq 24 ]; then
              echo "‚ùå ArgoCD server deployment not created after 2 minutes"
              echo ""
              echo "Final debugging info:"
              echo "ArgoCD CR:"
              kubectl get argocd -n argocd -o yaml
              echo ""
              echo "Operator logs (last 100 lines):"
              kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=100
              echo ""
              echo "All resources in argocd namespace:"
              kubectl get all -n argocd
              exit 1
            fi
          done
          kubectl wait --for=condition=available --timeout=5m \
            deployment/trading-argocd-server -n argocd || true
          kubectl wait --for=condition=available --timeout=5m \
            deployment/trading-argocd-repo-server -n argocd || true
          kubectl wait --for=condition=available --timeout=5m \
            deployment/trading-argocd-redis -n argocd || true

      - name: Configure ArgoCD Admin Password
        env:
          ADMIN_PASSWORD: ${{ secrets.argocd_admin_password }}
        run: |
          echo "Configuring ArgoCD admin password..."
          
          # Find the correct secret name
          SECRET_NAME=$(kubectl get secret -n argocd -o name 2>/dev/null | grep -E "argocd-secret|argocd.*cluster" | head -1 | cut -d'/' -f2)
          
          if [ -z "$SECRET_NAME" ]; then
            echo "‚ö†Ô∏è  No ArgoCD secret found yet, waiting..."
            sleep 5
            SECRET_NAME=$(kubectl get secret -n argocd -o name 2>/dev/null | grep -E "argocd-secret|argocd.*cluster" | head -1 | cut -d'/' -f2)
          fi
          
          if [ -z "$SECRET_NAME" ]; then
            echo "‚ùå Still no ArgoCD secret found"
            kubectl get secrets -n argocd
            exit 1
          fi
          
          echo "Found secret: $SECRET_NAME"
          
          if [ -n "$ADMIN_PASSWORD" ]; then
            echo "Setting custom admin password from GitHub secret..."
            
            # ArgoCD expects bcrypt hash - use Python to generate it
            BCRYPT_HASH=$(python3 -c "import bcrypt; print(bcrypt.hashpw(b'$ADMIN_PASSWORD', bcrypt.gensalt()).decode())" 2>/dev/null || echo "")
            
            if [ -n "$BCRYPT_HASH" ]; then
              echo "Generated bcrypt hash, updating secret..."
              kubectl -n argocd patch secret $SECRET_NAME --type='json' \
                -p="[{\"op\": \"replace\", \"path\": \"/data/admin.password\", \"value\": \"$(echo -n "$BCRYPT_HASH" | base64 -w0)\"}]"
              echo "‚úÖ Custom admin password set successfully"
            else
              echo "‚ö†Ô∏è  bcrypt not available, setting plaintext password..."
              echo "   ArgoCD will hash it on first login"
              kubectl -n argocd patch secret $SECRET_NAME --type='json' \
                -p="[{\"op\": \"replace\", \"path\": \"/data/admin.password\", \"value\": \"$(echo -n "$ADMIN_PASSWORD" | base64 -w0)\"}]"
              echo "‚úÖ Password set (will be hashed by ArgoCD)"
            fi
          else
            echo "‚ÑπÔ∏è  No custom password provided, using ArgoCD default"
            echo "   Get initial password with: kubectl -n argocd get secret $SECRET_NAME -o jsonpath='{.data.admin\\.password}' | base64 -d"
          fi

      - name: Deploy Parent App-of-Apps
        run: |
          echo "========================================"
          echo "Deploying Parent App-of-Apps"
          echo "========================================"
          
          echo "Parent app configuration:"
          cat config/app-of-apps/argocd/parent-app.yaml
          echo ""
          
          echo "Deploying parent app 'trading-system'..."
          kubectl apply -f config/app-of-apps/argocd/parent-app.yaml
          
          echo "‚úÖ Parent app deployed"
          echo ""
          
          echo "Waiting for parent app to sync..."
          sleep 10
          
          # Check if parent app exists and its status
          echo "Parent app status:"
          kubectl get application trading-system -n argocd -o yaml || true
          echo ""
          
          echo "Checking child applications..."
          kubectl get applications -n argocd
          echo ""
          
          echo "========================================"

      - name: Verify ArgoCD Applications Sync
        run: |
          echo "========================================"
          echo "Verifying ArgoCD Applications"
          echo "========================================"
          
          # Wait for child applications to be created
          echo "Waiting for child applications to be created by parent app..."
          MAX_ATTEMPTS=12
          for i in $(seq 1 $MAX_ATTEMPTS); do
            APP_COUNT=$(kubectl get applications -n argocd --no-headers 2>/dev/null | wc -l)
            if [ "$APP_COUNT" -ge 2 ]; then
              echo "‚úÖ Found $APP_COUNT applications (parent + children)"
              break
            fi
            
            echo "‚è≥ Attempt $i/$MAX_ATTEMPTS: Found $APP_COUNT applications, waiting for more..."
            sleep 5
            
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "‚ö†Ô∏è  Only found $APP_COUNT application(s) after waiting"
              echo "This may be normal if no child apps are configured yet"
            fi
          done
          
          echo ""
          echo "Current applications:"
          kubectl get applications -n argocd -o wide
          echo ""
          
          # Check sync status of each application
          echo "Application sync status:"
          for app in $(kubectl get applications -n argocd -o name); do
            APP_NAME=$(echo $app | cut -d'/' -f2)
            SYNC_STATUS=$(kubectl get $app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH_STATUS=$(kubectl get $app -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            
            echo "  $APP_NAME:"
            echo "    Sync: $SYNC_STATUS"
            echo "    Health: $HEALTH_STATUS"
          done
          
          echo ""
          echo "========================================"

      - name: Get Initial Admin Password
        run: |
          echo "Fetching admin password..."
          
          # Find the secret
          SECRET_NAME=$(kubectl get secret -n argocd -o name | grep -E "argocd.*cluster|argocd.*secret" | head -1 | cut -d'/' -f2)
          
          if [ -z "$SECRET_NAME" ]; then
            echo "‚ö†Ô∏è  No ArgoCD secret found"
            kubectl get secrets -n argocd
            ADMIN_PASSWORD="<check ArgoCD logs or secrets>"
          else
            ADMIN_PASSWORD=$(kubectl -n argocd get secret $SECRET_NAME \
              -o jsonpath='{.data.admin\.password}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
            
            if [ -z "$ADMIN_PASSWORD" ]; then
              echo "‚ö†Ô∏è  Password field empty, trying alternative fields..."
              kubectl get secret $SECRET_NAME -n argocd -o yaml
              ADMIN_PASSWORD="<check secret above>"
            fi
          fi
          echo "::add-mask::$ADMIN_PASSWORD"
          echo ""
          echo "=========================================="
          echo "ArgoCD Admin Credentials:"
          echo "Username: admin"
          echo "Password: $ADMIN_PASSWORD"
          echo "=========================================="

      - name: Verify ArgoCD UI Accessibility via Ingress
        run: |
          echo "========================================"
          echo "Verifying ArgoCD UI via Traefik Ingress"
          echo "========================================"
          
          CONTROL_IP="${{ inputs.control_plane_ip }}"
          
          # Check if Ingress exists
          echo "Checking for ArgoCD Ingress..."
          if ! kubectl get ingress -n argocd 2>/dev/null | grep -q "trading-argocd"; then
            echo "‚ö†Ô∏è  ArgoCD Ingress not found yet"
            echo "Available ingresses:"
            kubectl get ingress -n argocd || echo "No ingresses in argocd namespace"
            echo ""
            echo "This may take a moment for the operator to create..."
            sleep 10
          fi
          
          # Get Ingress details
          INGRESS_NAME=$(kubectl get ingress -n argocd -o name 2>/dev/null | grep "trading-argocd" | head -1 | cut -d'/' -f2 || echo "")
          
          if [ -n "$INGRESS_NAME" ]; then
            echo "‚úÖ Found Ingress: $INGRESS_NAME"
            kubectl get ingress $INGRESS_NAME -n argocd
            echo ""
          fi
          
          # Check Traefik service for external access
          echo "Checking Traefik LoadBalancer service..."
          kubectl get svc -n kube-system -l app.kubernetes.io/name=traefik || true
          echo ""
          
          # Wait for ArgoCD server to be ready
          echo "Waiting for ArgoCD server pod to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=trading-argocd-server -n argocd --timeout=120s || {
            echo "‚ö†Ô∏è  ArgoCD server pod not ready"
            kubectl get pods -n argocd
          }
          
          echo ""
          echo "Waiting for ArgoCD server to fully initialize..."
          sleep 30
          
          # Test HTTP accessibility via port 80 (Traefik)
          echo "Testing HTTP accessibility via Traefik (port 80)..."
          
          # Extract hostname from deployed ArgoCD CR
          ARGOCD_HOST=$(kubectl get argocd trading-argocd -n argocd -o jsonpath='{.spec.server.host}' 2>/dev/null || echo "argocd.dev.trading.local")
          echo "üìç Using hostname from ArgoCD CR: ${ARGOCD_HOST}"
          echo ""
          
          MAX_ATTEMPTS=15
          for i in $(seq 1 $MAX_ATTEMPTS); do
            # Test with Host header from ArgoCD CR
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 --max-time 10 \
              -H "Host: ${ARGOCD_HOST}" \
              "http://$CONTROL_IP" 2>/dev/null || echo "000")
            
            if echo "$HTTP_CODE" | grep -q "200\|302\|307\|308"; then
              echo "‚úÖ ArgoCD UI is accessible via Traefik Ingress"
              echo "   HTTP Status: $HTTP_CODE"
              echo "   Access via: http://$CONTROL_IP (with Host: ${ARGOCD_HOST})"
              echo "   Or add to /etc/hosts: $CONTROL_IP ${ARGOCD_HOST}"
              break
            fi
            
            echo "‚è≥ Attempt $i/$MAX_ATTEMPTS: HTTP $HTTP_CODE, waiting for Ingress to respond..."
            sleep 5
            
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "‚ö†Ô∏è  ArgoCD UI not accessible via Ingress after $MAX_ATTEMPTS attempts"
              echo ""
              echo "Debugging information:"
              echo "===================="
              echo "Ingress details:"
              kubectl get ingress -n argocd -o wide || true
              echo ""
              echo "Traefik pods:"
              kubectl get pods -n kube-system -l app.kubernetes.io/name=traefik || true
              echo ""
              echo "ArgoCD server service:"
              kubectl get svc -n argocd -l app.kubernetes.io/name=trading-argocd-server || true
              echo ""
              echo "ArgoCD server pods:"
              kubectl get pods -n argocd -l app.kubernetes.io/name=trading-argocd-server || true
              echo ""
              echo "===================="
              echo "‚ö†Ô∏è  Manual verification:"
              echo "   curl -H 'Host: ${ARGOCD_HOST}' http://$CONTROL_IP"
              echo ""
              echo "Continuing deployment..."
            fi
          done
          
          echo "========================================"

      - name: Verify ArgoCD Installation
        run: |
          CONTROL_IP="${{ inputs.control_plane_ip }}"
          
          echo "=========================================="
          echo "  ArgoCD Installation Summary"
          echo "=========================================="
          echo "Namespace: argocd"
          echo ""
          echo "Access Methods:"
          echo "  1. Via Traefik Ingress (port 80):"
          echo "     curl -H 'Host: argocd.dev.trading.local' http://$CONTROL_IP"
          echo ""
          echo "  2. Add to /etc/hosts (or C:\\Windows\\System32\\drivers\\etc\\hosts):"
          echo "     $CONTROL_IP argocd.dev.trading.local"
          echo "     Then browse: http://argocd.dev.trading.local"
          echo ""
          echo "Credentials:"
          echo "  Username: admin"
          echo "  Password: (see previous step)"
          echo ""
          echo "Pods:"
          kubectl get pods -n argocd
          echo ""
          echo "Services:"
          kubectl get svc -n argocd
          echo ""
          echo "Ingress:"
          kubectl get ingress -n argocd 2>/dev/null || echo "No ingress configured yet"
          echo ""
          echo "Applications:"
          kubectl get applications -n argocd 2>/dev/null || echo "No applications yet"
          echo "=========================================="

