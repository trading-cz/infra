name: '03 Reusable: Deploy ArgoCD'

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy (dev or prod)'
        required: true
        type: string
      control_plane_ip:
        description: 'Control Plane IP'
        required: true
        type: string
      kafka_public_ip:
        description: 'Public IP of Kafka Node'
        required: true
        type: string
    secrets:
      ssh_private_key:
        description: 'SSH private key for server access'
        required: true
      token_git_repo_config:
        description: 'Token for config repo access'
        required: true
      argocd_admin_password:
        description: 'Admin password for ArgoCD'
        required: false

jobs:
  deploy-argocd:
    name: Install ArgoCD Operator
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ssh_private_key }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Download Kubeconfig
        run: |
          CONTROL_IP="${{ inputs.control_plane_ip }}"
          mkdir -p ~/.kube
          
          echo "üì• Downloading kubeconfig from $CONTROL_IP..."
          # Retry loop for robustness
          for i in {1..5}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$CONTROL_IP "cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config 2>/dev/null; then
              sed -i "s/127.0.0.1/$CONTROL_IP/g" ~/.kube/config
              chmod 600 ~/.kube/config
              echo "‚úÖ Kubeconfig downloaded"
              break
            fi
            echo "‚ö†Ô∏è Retry $i/5..."
            sleep 5
          done

      - name: Install ArgoCD Operator
        run: |
          echo "üì¶ Installing ArgoCD Operator..."
          # Install ArgoCD Operator (Non-OLM)
          # Use server-side apply to avoid "metadata.annotations: Too long" error for CRDs
          kubectl apply --server-side -k https://github.com/argoproj-labs/argocd-operator/config/default?ref=v0.15.0-1
          
          echo "‚è≥ Waiting for Operator..."
          kubectl wait --for=condition=available deployment/argocd-operator-controller-manager -n argocd-operator-system --timeout=300s

      - name: Checkout Config Repo
        uses: actions/checkout@v4
        with:
          repository: trading-cz/config
          path: config
          token: ${{ secrets.token_git_repo_config }}

      - name: Bootstrap ArgoCD Instance
        run: |
          echo "üöÄ Creating ArgoCD Namespace..."
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

          echo "üîß Patching Kafka Config with Public IP..."
          # We need to inject the real Public IP into the Kafka CR before applying it
          # This is a simple text replacement in the checked-out config
          KAFKA_IP="${{ inputs.kafka_public_ip }}"
          sed -i "s/advertisedHost: .*/advertisedHost: $KAFKA_IP/" config/base/kafka/kafka.yaml
          
          echo "üå± Bootstrapping ArgoCD from Config Repo (${{ inputs.environment }})..."
          # Apply the environment-specific overlay which contains the ArgoCD CR
          kubectl apply -k config/overlays/${{ inputs.environment }}

      - name: Verify ArgoCD Instance
        run: |
          echo "‚è≥ Waiting for ArgoCD Server deployment creation..."
          # Wait for the operator to create the deployment (async operation)
          for i in {1..60}; do
            if kubectl get deployment/trading-argocd-server -n argocd &> /dev/null; then
              echo "‚úÖ Deployment found!"
              break
            fi
            echo "Waiting for deployment creation... ($i/60)"
            sleep 2
          done

          echo "‚è≥ Waiting for ArgoCD Server (trading-argocd-server)..."
          # The operator creates resources with the CR name as prefix
          kubectl wait --for=condition=available deployment/trading-argocd-server -n argocd --timeout=300s
          kubectl wait --for=condition=available deployment/trading-argocd-repo-server -n argocd --timeout=300s
          
          echo "‚úÖ ArgoCD is UP!"
          kubectl get pods -n argocd

      - name: Set ArgoCD Admin Password
        env:
          ARGOCD_ADMIN_PASSWORD: ${{ secrets.argocd_admin_password }}
        run: |
          if [ -z "$ARGOCD_ADMIN_PASSWORD" ]; then
            echo "No admin password provided. Skipping."
            exit 0
          fi

          echo "üîê Updating ArgoCD admin password..."
          pip install bcrypt
          
          # Generate bcrypt hash
          HASH=$(python3 -c 'import bcrypt, os; print(bcrypt.hashpw(os.environ["ARGOCD_ADMIN_PASSWORD"].encode(), bcrypt.gensalt()).decode())')
          
          # Patch the secret using stringData (automatically base64 encodes)
          # The secret name is <cr-name>-cluster -> trading-argocd-cluster
          kubectl patch secret trading-argocd-cluster -n argocd --type=merge -p "{\"stringData\": {\"admin.password\": \"$HASH\"}}"
          
          echo "‚úÖ Password updated. Restarting ArgoCD server..."
          kubectl rollout restart deployment/trading-argocd-server -n argocd

      - name: Debug on Failure
        if: failure()
        run: |
          echo "‚ùå ArgoCD Deployment Failed. Dumping State..."
          echo "::group::ArgoCD Operator Pods"
          kubectl get pods -n argocd-operator-system -o wide || true
          echo "::endgroup::"
          echo "::group::ArgoCD Operator Logs"
          kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=50 || true
          echo "::endgroup::"
          echo "::group::ArgoCD Namespace Pods"
          kubectl get pods -n argocd -o wide || true
          echo "::endgroup::"
          echo "::group::ArgoCD Events"
          kubectl get events -n argocd --sort-by='.lastTimestamp' || true
          echo "::endgroup::"
          echo "::group::ArgoCD Server Logs"
          kubectl logs -n argocd -l app.kubernetes.io/name=trading-argocd-server --tail=50 || true
          echo "::endgroup::"

