name: 'Reusable: Deploy ArgoCD'

on:
  workflow_call:
    inputs:
      control_plane_ip:
        description: 'Control Plane IP'
        required: true
        type: string
      environment:
        description: 'Deployment environment (dev|prod)'
        required: true
        type: string
    secrets:
      ssh_private_key:
        description: 'SSH private key for server access'
        required: true
      argocd_admin_password:
        description: 'ArgoCD admin password'
        required: false
      token_git_repo_config:
        description: 'Token for config repo'
        required: true

jobs:
  deploy:
    name: Deploy and Verify ArgoCD
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Infra Repository
        uses: actions/checkout@v4
        with:
          path: infra

      - name: Checkout Config Repository
        uses: actions/checkout@v4
        with:
          repository: trading-cz/config
          ref: main
          path: config
          token: ${{ secrets.token_git_repo_config }}

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ssh_private_key }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          echo "‚úÖ SSH key configured"

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          echo "‚úÖ kubectl installed"

      - name: Download Kubeconfig from Control Plane
        run: |
          CONTROL_IP="${{ inputs.control_plane_ip }}"
          
          echo "=========================================="
          echo "Downloading Kubeconfig from Control Plane"
          echo "Control Plane IP: $CONTROL_IP"
          echo "=========================================="
          
          mkdir -p ~/.kube
          
          echo "üì• Fetching kubeconfig via SSH..."
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$CONTROL_IP "cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config 2>/dev/null; then
            echo "‚úÖ Kubeconfig downloaded successfully"
          else
            echo "‚ùå Failed to download kubeconfig from control plane"
            echo "   Verify:"
            echo "   1. Control plane IP is correct: $CONTROL_IP"
            echo "   2. SSH access is working: ssh root@$CONTROL_IP"
            echo "   3. K3s is installed: /etc/rancher/k3s/k3s.yaml exists"
            exit 1
          fi
          
          # Replace localhost with actual control plane IP
          sed -i "s/127.0.0.1/$CONTROL_IP/g" ~/.kube/config
          chmod 600 ~/.kube/config
          
          FILE_SIZE=$(stat -c%s ~/.kube/config)
          echo "‚úÖ Kubeconfig prepared (size: $FILE_SIZE bytes)"
          
          echo ""
          echo "Testing cluster connection..."
          if kubectl cluster-info > /tmp/cluster_info.log 2>&1; then
            echo "‚úÖ Cluster connection successful!"
            cat /tmp/cluster_info.log
          else
            echo "‚ùå Cannot connect to cluster"
            cat /tmp/cluster_info.log
            echo ""
            echo "Kubeconfig content (first 10 lines):"
            head -n 10 ~/.kube/config
            exit 1
          fi
          
          echo ""
          echo "=========================================="

      - name: Install ArgoCD Operator
        env:
          KUBECONFIG: /home/runner/.kube/config
        run: |
          echo "=========================================="
          echo "Installing ArgoCD Operator v0.15.0"
          echo "Method: kubectl apply (manual installation)"
          echo "=========================================="
          
          # Verify kubectl can connect
          echo "Verifying cluster connectivity..."
          kubectl get nodes || {
            echo "ERROR: Cannot connect to Kubernetes cluster"
            echo "KUBECONFIG: $KUBECONFIG"
            exit 1
          }
          
          echo ""
          echo "Current cluster state:"
          echo "Namespaces:"
          kubectl get namespaces
          echo ""
          echo "Existing ArgoCD resources:"
          kubectl get all -n argocd 2>/dev/null || echo "No resources in argocd namespace"
          kubectl get all -n argocd-operator-system 2>/dev/null || echo "No resources in argocd-operator-system namespace"
          echo ""
          
          # Download and extract the operator release
          OPERATOR_VERSION="v0.15.0"
          echo "Downloading ArgoCD Operator ${OPERATOR_VERSION}..."
          curl -sL "https://github.com/argoproj-labs/argocd-operator/archive/refs/tags/${OPERATOR_VERSION}.tar.gz" -o argocd-operator.tar.gz
          
          echo "Extracting archive..."
          tar -xzf argocd-operator.tar.gz
          
          echo ""
          echo "Deploying operator using kustomize..."
          kubectl create namespace argocd 2>/dev/null || echo "Namespace argocd already exists"
          kubectl create namespace argocd-operator-system 2>/dev/null || echo "Namespace argocd-operator-system already exists"
          
          # Use kubectl create instead of apply to avoid CRD annotation size issues
          echo "Installing operator manifests..."
          kubectl kustomize argocd-operator-${OPERATOR_VERSION#v}/config/default | kubectl create -f - || {
            echo "‚ö†Ô∏è  Some resources already exist, updating them..."
            kubectl kustomize argocd-operator-${OPERATOR_VERSION#v}/config/default | kubectl apply -f - --server-side=true --force-conflicts
          }
          
          echo ""
          echo "Waiting for operator to be ready..."
          kubectl wait --for=condition=available --timeout=5m \
            deployment/argocd-operator-controller-manager \
            -n argocd-operator-system || {
              echo "ERROR: Operator deployment failed to become ready"
              echo "Deployment status:"
              kubectl get deployment -n argocd-operator-system
              echo ""
              echo "Pod status:"
              kubectl get pods -n argocd-operator-system
              echo ""
              echo "Pod logs:"
              kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=50
              exit 1
            }
          
          echo ""
          echo "Verifying operator installation..."
          kubectl get pods -n argocd-operator-system
          
          echo ""
          echo "Checking ArgoCD CRDs..."
          kubectl get crd | grep argoproj || {
            echo "WARNING: ArgoCD CRDs not found"
            kubectl get crd
            exit 1
          }
          
          echo ""
          echo "=========================================="
          echo "ArgoCD Operator installed successfully!"
          echo "=========================================="

      - name: Deploy ArgoCD Instance
        run: |
          echo "=========================================="
          echo "Deploying ArgoCD CR from config repository"
          echo "=========================================="
          
          echo "ArgoCD CR file:"
          cat config/base/operators/argocd/argocd.yaml
          echo ""
          
          echo "Applying ArgoCD CR..."
          if ! kubectl apply -k config/base/operators/argocd; then
            echo ""
            echo "‚ùå Failed to deploy ArgoCD CR"
            echo ""
            echo "Debugging information:"
            echo "===================="
            echo "Operator pod status:"
            kubectl get pods -n argocd-operator-system
            echo ""
            echo "Operator logs (last 50 lines):"
            kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=50 || true
            echo ""
            echo "ArgoCD CRD version info:"
            kubectl get crd argocds.argoproj.io -o yaml | grep -A 20 "versions:" || true
            echo ""
            echo "Available API versions for ArgoCD:"
            kubectl api-resources | grep argocd || true
            exit 1
          fi
          
          echo "‚úÖ ArgoCD CR deployed successfully"
          echo ""
          echo "=========================================="

      - name: 'Verification Step 1: ArgoCD CR Creation'
        run: |
          echo "=========================================="
          echo "Verification Step 1: ArgoCD CR Creation"
          echo "=========================================="
          
          echo "Waiting for ArgoCD CR to be created..."
          ATTEMPT=0
          while [ $ATTEMPT -lt 30 ]; do
            if kubectl get argocd trading-argocd -n argocd &>/dev/null 2>&1; then
              echo "‚úÖ ArgoCD CR 'trading-argocd' found"
              break
            fi
            echo "  Attempt $((ATTEMPT+1))/30: Waiting..."
            sleep 2
            ((ATTEMPT++))
          done
          
          if [ $ATTEMPT -eq 30 ]; then
            echo "‚ùå ArgoCD CR not created after 1 minute"
            echo "Debug info:"
            kubectl get argocd -n argocd -o yaml
            kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=50 || true
            exit 1
          fi
          
          echo ""
          echo "Checking ArgoCD CR phase..."
          PHASE=$(kubectl get argocd trading-argocd -n argocd -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
          echo "  Phase: $PHASE"
          
          echo ""
          echo "ArgoCD CR details:"
          kubectl get argocd trading-argocd -n argocd -o wide
          echo ""
          echo "‚úÖ ArgoCD CR verified"
          echo "=========================================="

      - name: 'Verification Step 2: ArgoCD Components Created'
        run: |
          echo "=========================================="
          echo "Verification Step 2: ArgoCD Components Created"
          echo "=========================================="
          
          # First check if operator is still running
          echo "Checking if operator is still running..."
          OPERATOR_PODS=$(kubectl get pods -n argocd-operator-system --no-headers 2>/dev/null | wc -l)
          
          if [ "$OPERATOR_PODS" -eq 0 ]; then
            echo "‚ùå Operator pods not found! Reinstalling operator..."
            
            OPERATOR_VERSION="v0.15.0"
            curl -sL "https://github.com/argoproj-labs/argocd-operator/archive/refs/tags/${OPERATOR_VERSION}.tar.gz" -o argocd-operator.tar.gz
            tar -xzf argocd-operator.tar.gz
            
            echo "Redeploying operator..."
            kubectl kustomize argocd-operator-${OPERATOR_VERSION#v}/config/default | kubectl apply -f - --server-side=true --force-conflicts
            
            echo "Waiting for operator to start..."
            sleep 15
          fi
          
          EXPECTED_COMPONENTS=("trading-argocd-server" "trading-argocd-repo-server" "trading-argocd-redis" "trading-argocd-application-controller")
          
          echo "Waiting for all ArgoCD components to be created..."
          ATTEMPT=0
          FOUND_COMPONENTS=0
          
          while [ $ATTEMPT -lt 120 ]; do
            FOUND_COMPONENTS=0
            for COMP in "${EXPECTED_COMPONENTS[@]}"; do
              if kubectl get deployment "$COMP" -n argocd &>/dev/null 2>&1 || \
                 kubectl get statefulset "$COMP" -n argocd &>/dev/null 2>&1; then
                ((FOUND_COMPONENTS++))
              fi
            done
            
            if [ $FOUND_COMPONENTS -eq ${#EXPECTED_COMPONENTS[@]} ]; then
              echo "‚úÖ All $FOUND_COMPONENTS components found"
              break
            fi
            
            echo "  Attempt $((ATTEMPT+1))/120: Found $FOUND_COMPONENTS/${#EXPECTED_COMPONENTS[@]} components..."
            sleep 1
            ((ATTEMPT++))
          done
          
          if [ $FOUND_COMPONENTS -ne ${#EXPECTED_COMPONENTS[@]} ]; then
            echo ""
            echo "‚ùå Not all components created (found $FOUND_COMPONENTS/${#EXPECTED_COMPONENTS[@]})"
            echo ""
            echo "Available resources in argocd namespace:"
            kubectl get all -n argocd
            echo ""
            echo "Operator status:"
            kubectl get pods -n argocd-operator-system 2>/dev/null || echo "Operator namespace empty"
            echo ""
            echo "Operator logs (if available):"
            kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=50 2>/dev/null || echo "No logs found"
            echo ""
            echo "ArgoCD CR:"
            kubectl get argocd trading-argocd -n argocd -o yaml || true
            exit 1
          fi
          
          echo ""
          echo "Component status:"
          kubectl get all -n argocd
          echo "=========================================="
          echo "=========================================="

      - name: 'Verification Step 3: ArgoCD Components Ready'
        run: |
          echo "=========================================="
          echo "Verification Step 3: ArgoCD Components Ready"
          echo "=========================================="
          
          EXPECTED_COMPONENTS=("trading-argocd-server" "trading-argocd-repo-server" "trading-argocd-redis")
          
          echo "Waiting for ArgoCD components to be READY..."
          for COMP in "${EXPECTED_COMPONENTS[@]}"; do
            echo ""
            echo "Checking $COMP..."
            
            if ! kubectl wait --for=condition=available --timeout=300s deployment/"$COMP" -n argocd 2>/dev/null; then
              echo "‚ö†Ô∏è  deployment/$COMP timed out waiting to be ready"
              echo "   Current status:"
              kubectl get deployment "$COMP" -n argocd -o wide || true
              echo ""
              echo "   Pod status:"
              kubectl get pods -n argocd -l "app.kubernetes.io/name=$COMP" -o wide || true
              echo ""
              echo "   Pod logs (last 30 lines):"
              kubectl logs -n argocd -l "app.kubernetes.io/name=$COMP" --tail=30 --all-containers=true || true
              echo ""
              echo "   Continuing to next component..."
            else
              echo "‚úÖ deployment/$COMP is ready"
            fi
          done
          
          # Special handling for application-controller (StatefulSet)
          echo ""
          echo "Checking trading-argocd-application-controller (StatefulSet)..."
          if kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=trading-argocd-application-controller \
            -n argocd --timeout=300s 2>/dev/null; then
            echo "‚úÖ trading-argocd-application-controller pod is ready"
          else
            echo "‚ö†Ô∏è  trading-argocd-application-controller pod timed out"
            kubectl get pods -n argocd -l app.kubernetes.io/name=trading-argocd-application-controller -o wide || true
          fi
          
          echo ""
          echo "Final component status:"
          kubectl get all -n argocd
          echo "=========================================="

      - name: Configure ArgoCD Admin Password
        env:
          ADMIN_PASSWORD: ${{ secrets.argocd_admin_password }}
        run: |
          echo "Configuring ArgoCD admin password..."
          
          # Find the correct secret name
          SECRET_NAME=$(kubectl get secret -n argocd -o name 2>/dev/null | grep -E "argocd-secret|argocd.*cluster" | head -1 | cut -d'/' -f2)
          
          if [ -z "$SECRET_NAME" ]; then
            echo "‚ö†Ô∏è  No ArgoCD secret found yet, waiting..."
            sleep 5
            SECRET_NAME=$(kubectl get secret -n argocd -o name 2>/dev/null | grep -E "argocd-secret|argocd.*cluster" | head -1 | cut -d'/' -f2)
          fi
          
          if [ -z "$SECRET_NAME" ]; then
            echo "‚ùå Still no ArgoCD secret found"
            kubectl get secrets -n argocd
            exit 1
          fi
          
          echo "Found secret: $SECRET_NAME"
          
          if [ -n "$ADMIN_PASSWORD" ]; then
            echo "Setting custom admin password from GitHub secret..."
            
            # ArgoCD expects bcrypt hash - use Python to generate it
            BCRYPT_HASH=$(python3 -c "import bcrypt; print(bcrypt.hashpw(b'$ADMIN_PASSWORD', bcrypt.gensalt()).decode())" 2>/dev/null || echo "")
            
            if [ -n "$BCRYPT_HASH" ]; then
              echo "Generated bcrypt hash, updating secret..."
              kubectl -n argocd patch secret $SECRET_NAME --type='json' \
                -p="[{\"op\": \"replace\", \"path\": \"/data/admin.password\", \"value\": \"$(echo -n "$BCRYPT_HASH" | base64 -w0)\"}]"
              echo "‚úÖ Custom admin password set successfully"
            else
              echo "‚ö†Ô∏è  bcrypt not available, setting plaintext password..."
              echo "   ArgoCD will hash it on first login"
              kubectl -n argocd patch secret $SECRET_NAME --type='json' \
                -p="[{\"op\": \"replace\", \"path\": \"/data/admin.password\", \"value\": \"$(echo -n "$ADMIN_PASSWORD" | base64 -w0)\"}]"
              echo "‚úÖ Password set (will be hashed by ArgoCD)"
            fi
          else
            echo "‚ÑπÔ∏è  No custom password provided, using ArgoCD default"
            echo "   Get initial password with: kubectl -n argocd get secret $SECRET_NAME -o jsonpath='{.data.admin\\.password}' | base64 -d"
          fi

      - name: Deploy Parent App-of-Apps
        run: |
          echo "========================================"
          echo "Deploying Parent App-of-Apps"
          echo "========================================"
          
          echo "Parent app configuration:"
          cat config/app-of-apps/argocd/parent-app.yaml
          echo ""
          
          echo "Deploying parent app 'trading-system'..."
          kubectl apply -f config/app-of-apps/argocd/parent-app.yaml
          
          echo "‚úÖ Parent app deployed"
          echo ""
          
          echo "Waiting for parent app to sync..."
          sleep 10
          
          # Check if parent app exists and its status
          echo "Parent app status:"
          kubectl get application trading-system -n argocd -o yaml || true
          echo ""
          
          echo "Checking child applications..."
          kubectl get applications -n argocd
          echo ""
          
          echo "========================================"

      - name: 'Verification Step 4: ArgoCD Services'
        run: |
          echo "=========================================="
          echo "Verification Step 4: ArgoCD Services"
          echo "=========================================="
          
          echo "Checking services are created and have ClusterIPs..."
          
          SERVICES=("trading-argocd-server" "trading-argocd-repo-server" "trading-argocd-redis")
          
          for SVC in "${SERVICES[@]}"; do
            if kubectl get svc "$SVC" -n argocd &>/dev/null; then
              CLUSTER_IP=$(kubectl get svc "$SVC" -n argocd -o jsonpath='{.spec.clusterIP}')
              if [ -n "$CLUSTER_IP" ] && [ "$CLUSTER_IP" != "None" ]; then
                echo "‚úÖ Service $SVC has ClusterIP: $CLUSTER_IP"
              else
                echo "‚ö†Ô∏è  Service $SVC has no ClusterIP"
              fi
            else
              echo "‚ö†Ô∏è  Service $SVC not found"
            fi
          done
          
          echo ""
          echo "Full service details:"
          kubectl get svc -n argocd -o wide
          echo ""
          echo "=========================================="

      - name: Verify ArgoCD Applications Sync
        run: |
          echo "=========================================="
          echo "Verification Step 5: Parent App-of-Apps Deployment"
          echo "=========================================="
          
          echo "Checking if parent app 'trading-system' exists..."
          ATTEMPT=0
          while [ $ATTEMPT -lt 30 ]; do
            if kubectl get application trading-system -n argocd &>/dev/null; then
              echo "‚úÖ Parent app 'trading-system' found"
              break
            fi
            echo "  Attempt $((ATTEMPT+1))/30: Waiting for parent app..."
            sleep 2
            ((ATTEMPT++))
          done
          
          if [ $ATTEMPT -eq 30 ]; then
            echo "‚ö†Ô∏è  Parent app not found after 1 minute"
            echo "   This is expected if not deployed yet"
            echo ""
            echo "Available applications:"
            kubectl get applications -n argocd || echo "No applications"
            exit 0
          fi
          
          echo ""
          echo "Monitoring parent app sync status (waiting up to 5 minutes)..."
          ATTEMPT=0
          while [ $ATTEMPT -lt 150 ]; do
            SYNC=$(kubectl get application trading-system -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl get application trading-system -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            
            echo "  Attempt $((ATTEMPT+1))/150: Sync=$SYNC, Health=$HEALTH"
            
            if [ "$SYNC" != "Unknown" ]; then
              echo "‚úÖ Parent app has reached sync status: $SYNC (Health: $HEALTH)"
              break
            fi
            
            sleep 2
            ((ATTEMPT++))
          done
          
          if [ "$SYNC" = "Unknown" ]; then
            echo "‚ö†Ô∏è  Parent app sync status is still Unknown"
            echo ""
            echo "Checking error conditions..."
            ERROR_MSG=$(kubectl get application trading-system -n argocd -o jsonpath='{.status.conditions[?(@.type=="ComparisonError")].message}' 2>/dev/null || echo "")
            if [ -n "$ERROR_MSG" ]; then
              echo "Comparison Error detected:"
              echo "  $ERROR_MSG"
              echo ""
              echo "This is often due to:"
              echo "  - ArgoCD repo-server connecting to Git repository"
              echo "  - Network connectivity issues"
              echo "  - Repository access problems"
            fi
          fi
          
          echo ""
          echo "Parent app full status:"
          kubectl get application trading-system -n argocd -o yaml | head -80
          echo "=========================================="

      - name: 'Verification Step 6: Child Applications'
        run: |
          echo "=========================================="
          echo "Verification Step 6: Child Applications"
          echo "=========================================="
          
          echo "Waiting for child applications to be created by parent app..."
          ATTEMPT=0
          while [ $ATTEMPT -lt 120 ]; do
            APP_COUNT=$(kubectl get applications -n argocd --no-headers 2>/dev/null | wc -l)
            
            if [ "$APP_COUNT" -ge 2 ]; then
              echo "‚úÖ Found $APP_COUNT applications"
              break
            fi
            
            echo "  Attempt $((ATTEMPT+1))/120: Found $APP_COUNT application(s)..."
            sleep 2
            ((ATTEMPT++))
          done
          
          APP_COUNT=$(kubectl get applications -n argocd --no-headers 2>/dev/null | wc -l)
          
          if [ "$APP_COUNT" -lt 2 ]; then
            echo "‚ö†Ô∏è  Only $APP_COUNT application(s) found (expected parent + children)"
            echo "   This may be normal if child apps are not configured"
          fi
          
          echo ""
          echo "All applications:"
          kubectl get applications -n argocd -o wide
          
          echo ""
          echo "Application statuses:"
          for app in $(kubectl get applications -n argocd -o name 2>/dev/null); do
            APP_NAME=$(echo "$app" | cut -d'/' -f2)
            SYNC=$(kubectl get "$app" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl get "$app" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            REV=$(kubectl get "$app" -n argocd -o jsonpath='{.status.syncedRevision}' 2>/dev/null || echo "N/A")
            
            echo ""
            echo "  $APP_NAME:"
            echo "    Sync: $SYNC"
            echo "    Health: $HEALTH"
            echo "    Synced Revision: $REV"
            
            # Check for errors
            if [ "$SYNC" = "Unknown" ]; then
              CONDITIONS=$(kubectl get "$app" -n argocd -o jsonpath='{.status.conditions[?(@.type=="ComparisonError")].message}' 2>/dev/null || echo "")
              if [ -n "$CONDITIONS" ]; then
                echo "    ‚ö†Ô∏è  Error: ${CONDITIONS:0:100}..."
              fi
            fi
          done
          
          echo ""
          echo "=========================================="

      - name: Get Initial Admin Password
        run: |
          echo "Fetching admin password..."
          
          # Find the secret
          SECRET_NAME=$(kubectl get secret -n argocd -o name | grep -E "argocd.*cluster|argocd.*secret" | head -1 | cut -d'/' -f2)
          
          if [ -z "$SECRET_NAME" ]; then
            echo "‚ö†Ô∏è  No ArgoCD secret found"
            kubectl get secrets -n argocd
            ADMIN_PASSWORD="<check ArgoCD logs or secrets>"
          else
            ADMIN_PASSWORD=$(kubectl -n argocd get secret $SECRET_NAME \
              -o jsonpath='{.data.admin\.password}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
            
            if [ -z "$ADMIN_PASSWORD" ]; then
              echo "‚ö†Ô∏è  Password field empty, trying alternative fields..."
              kubectl get secret $SECRET_NAME -n argocd -o yaml
              ADMIN_PASSWORD="<check secret above>"
            fi
          fi
          echo "::add-mask::$ADMIN_PASSWORD"
          echo ""
          echo "=========================================="
          echo "ArgoCD Admin Credentials:"
          echo "Username: admin"
          echo "Password: $ADMIN_PASSWORD"
          echo "=========================================="

      - name: Verify ArgoCD UI Accessibility via Ingress
        run: |
          echo "========================================"
          echo "Verifying ArgoCD UI via Traefik Ingress"
          echo "========================================"
          
          CONTROL_IP="${{ inputs.control_plane_ip }}"
          
          # Check if Ingress exists
          echo "Checking for ArgoCD Ingress..."
          if ! kubectl get ingress -n argocd 2>/dev/null | grep -q "trading-argocd"; then
            echo "‚ö†Ô∏è  ArgoCD Ingress not found yet"
            echo "Available ingresses:"
            kubectl get ingress -n argocd || echo "No ingresses in argocd namespace"
            echo ""
            echo "This may take a moment for the operator to create..."
            sleep 10
          fi
          
          # Get Ingress details
          INGRESS_NAME=$(kubectl get ingress -n argocd -o name 2>/dev/null | grep "trading-argocd" | head -1 | cut -d'/' -f2 || echo "")
          
          if [ -n "$INGRESS_NAME" ]; then
            echo "‚úÖ Found Ingress: $INGRESS_NAME"
            kubectl get ingress $INGRESS_NAME -n argocd
            echo ""
          fi
          
          # Check Traefik service for external access
          echo "Checking Traefik LoadBalancer service..."
          kubectl get svc -n kube-system -l app.kubernetes.io/name=traefik || true
          echo ""
          
          # Wait for ArgoCD server to be ready
          echo "Waiting for ArgoCD server pod to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=trading-argocd-server -n argocd --timeout=120s || {
            echo "‚ö†Ô∏è  ArgoCD server pod not ready"
            kubectl get pods -n argocd
          }
          
          echo ""
          echo "Waiting for ArgoCD server to fully initialize..."
          sleep 30
          
          # Test HTTP accessibility via port 80 (Traefik)
          echo "Testing HTTP accessibility via Traefik (port 80)..."
          
          # Extract hostname from deployed ArgoCD CR
          ARGOCD_HOST=$(kubectl get argocd trading-argocd -n argocd -o jsonpath='{.spec.server.host}' 2>/dev/null || echo "argocd.dev.trading.local")
          echo "üìç Using hostname from ArgoCD CR: ${ARGOCD_HOST}"
          echo ""
          
          MAX_ATTEMPTS=15
          for i in $(seq 1 $MAX_ATTEMPTS); do
            # Test with Host header from ArgoCD CR
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 --max-time 10 \
              -H "Host: ${ARGOCD_HOST}" \
              "http://$CONTROL_IP" 2>/dev/null || echo "000")
            
            if echo "$HTTP_CODE" | grep -q "200\|302\|307\|308"; then
              echo "‚úÖ ArgoCD UI is accessible via Traefik Ingress"
              echo "   HTTP Status: $HTTP_CODE"
              echo "   Access via: http://$CONTROL_IP (with Host: ${ARGOCD_HOST})"
              echo "   Or add to /etc/hosts: $CONTROL_IP ${ARGOCD_HOST}"
              break
            fi
            
            echo "‚è≥ Attempt $i/$MAX_ATTEMPTS: HTTP $HTTP_CODE, waiting for Ingress to respond..."
            sleep 5
            
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "‚ö†Ô∏è  ArgoCD UI not accessible via Ingress after $MAX_ATTEMPTS attempts"
              echo ""
              echo "Debugging information:"
              echo "===================="
              echo "Ingress details:"
              kubectl get ingress -n argocd -o wide || true
              echo ""
              echo "Traefik pods:"
              kubectl get pods -n kube-system -l app.kubernetes.io/name=traefik || true
              echo ""
              echo "ArgoCD server service:"
              kubectl get svc -n argocd -l app.kubernetes.io/name=trading-argocd-server || true
              echo ""
              echo "ArgoCD server pods:"
              kubectl get pods -n argocd -l app.kubernetes.io/name=trading-argocd-server || true
              echo ""
              echo "===================="
              echo "‚ö†Ô∏è  Manual verification:"
              echo "   curl -H 'Host: ${ARGOCD_HOST}' http://$CONTROL_IP"
              echo ""
              echo "Continuing deployment..."
            fi
          done
          
          echo "========================================"

      - name: Verify ArgoCD Installation
        run: |
          CONTROL_IP="${{ inputs.control_plane_ip }}"
          
          echo "=========================================="
          echo "  ArgoCD Installation Summary"
          echo "=========================================="
          echo "Namespace: argocd"
          echo ""
          echo "Access Methods:"
          echo "  1. Via Traefik Ingress (port 80):"
          echo "     curl -H 'Host: argocd.dev.trading.local' http://$CONTROL_IP"
          echo ""
          echo "  2. Add to /etc/hosts (or C:\\Windows\\System32\\drivers\\etc\\hosts):"
          echo "     $CONTROL_IP argocd.dev.trading.local"
          echo "     Then browse: http://argocd.dev.trading.local"
          echo ""
          echo "Credentials:"
          echo "  Username: admin"
          echo "  Password: (see previous step)"
          echo ""
          echo "Pods:"
          kubectl get pods -n argocd
          echo ""
          echo "Services:"
          kubectl get svc -n argocd
          echo ""
          echo "Ingress:"
          kubectl get ingress -n argocd 2>/dev/null || echo "No ingress configured yet"
          echo ""
          echo "Applications:"
          kubectl get applications -n argocd 2>/dev/null || echo "No applications yet"
          echo "=========================================="

