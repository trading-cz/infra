name: '03 Reusable: Deploy ArgoCD'

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy (dev or prod)'
        required: true
        type: string
      control_plane_ip:
        description: 'Control Plane IP'
        required: true
        type: string
      kafka_public_ip:
        description: 'Public IP of Kafka Node'
        required: true
        type: string
    secrets:
      ssh_private_key:
        description: 'SSH private key for server access'
        required: true
      token_git_repo_config:
        description: 'Token for config repo access'
        required: true
      ghcr_token:
        description: 'GitHub Container Registry token for pulling private images'
        required: true
      argocd_admin_password:
        description: 'Admin password for ArgoCD'
        required: false

jobs:
  deploy-argocd:
    name: Install ArgoCD Operator
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ssh_private_key }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Download Kubeconfig
        run: |
          CONTROL_IP="${{ inputs.control_plane_ip }}"
          mkdir -p ~/.kube
          
          echo "üì• Downloading kubeconfig from $CONTROL_IP..."
          # Retry loop for robustness
          for i in {1..5}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$CONTROL_IP "cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config 2>/dev/null; then
              sed -i "s/127.0.0.1/$CONTROL_IP/g" ~/.kube/config
              chmod 600 ~/.kube/config
              echo "‚úÖ Kubeconfig downloaded"
              break
            fi
            echo "‚ö†Ô∏è Retry $i/5..."
            sleep 5
          done
          
      - name: Verify Operator Availability on Control Plane
        run: |
          echo "üîç Checking if required operators are running..."
          
          # Check for Prometheus Operator
          echo "Checking Prometheus Operator..."
          if kubectl get deployment -n monitoring prometheus-operator 2>/dev/null; then
            echo "‚úÖ Prometheus Operator deployment found"
            kubectl get pods -n monitoring -l app.kubernetes.io/name=prometheus-operator
          else
            echo "‚ö†Ô∏è  Prometheus Operator deployment NOT found yet (may still be starting)"
          fi
          
          # Check for Grafana Operator  
          echo "Checking Grafana Operator..."
          if kubectl get deployment -n monitoring grafana-operator 2>/dev/null; then
            echo "‚úÖ Grafana Operator deployment found"
            kubectl get pods -n monitoring -l app.kubernetes.io/name=grafana-operator
          else
            echo "‚ö†Ô∏è  Grafana Operator deployment NOT found yet (may still be starting)"
          fi
          
          # Check for Strimzi Operator
          echo "Checking Strimzi Operator..."
          if kubectl get deployment -n kafka strimzi-cluster-operator 2>/dev/null; then
            echo "‚úÖ Strimzi Operator deployment found"
          else
            echo "‚ÑπÔ∏è  Strimzi Operator not in 'kafka' namespace (may be in different namespace or not installed yet)"
          fi
          
          echo ""
          echo "Current monitoring namespace pods:"
          kubectl get pods -n monitoring -o wide 2>/dev/null || echo "monitoring namespace not accessible yet"

      - name: Install ArgoCD Operator
        run: |
          echo "üì¶ Installing ArgoCD Operator..."
          # Install ArgoCD Operator (Non-OLM)
          # Use server-side apply to avoid "metadata.annotations: Too long" error for CRDs
          kubectl apply --server-side -k https://github.com/argoproj-labs/argocd-operator/config/default?ref=v0.15.0-1
          
          echo "‚è≥ Waiting for Operator..."
          kubectl wait --for=condition=available deployment/argocd-operator-controller-manager -n argocd-operator-system --timeout=300s

      - name: Checkout Config Repo
        uses: actions/checkout@v4
        with:
          repository: trading-cz/config
          path: config
          token: ${{ secrets.token_git_repo_config }}

      - name: Bootstrap ArgoCD Instance
        run: |
          echo "üöÄ Creating ArgoCD Namespace..."
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

          echo "üîê Creating GHCR pull secret for ingestion-alpaca namespace..."
          kubectl create namespace ingestion-alpaca --dry-run=client -o yaml | kubectl apply -f -
          kubectl create secret docker-registry ghcr-secret \
            --namespace=ingestion-alpaca \
            --docker-server=ghcr.io \
            --docker-username=trading-cz \
            --docker-password=${{ secrets.ghcr_token }} \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "üîß Patching Kafka Config with Public IP..."
          # We need to inject the real Public IP into the Kafka CR before applying it
          # This is a simple text replacement in the checked-out config
          KAFKA_IP="${{ inputs.kafka_public_ip }}"
          sed -i "s/advertisedHost: .*/advertisedHost: $KAFKA_IP/" config/base/kafka/kafka.yaml
          
          echo "‚è≥ Waiting for Operator CRDs (Prometheus, Grafana, Strimzi)..."
          echo "Note: Operators take 60-120s to register their CRDs after installation"
          
          # Wait for Prometheus CRDs (up to 3 minutes)
          echo "Waiting for Prometheus CRDs..."
          for i in {1..90}; do
            if kubectl get crd prometheuses.monitoring.coreos.com servicemonitors.monitoring.coreos.com &>/dev/null; then
              echo "‚úÖ Prometheus CRDs available"
              break
            fi
            echo "  [$i/90] Still waiting for Prometheus CRDs..."
            sleep 2
          done
          
          if ! kubectl get crd prometheuses.monitoring.coreos.com &>/dev/null; then
            echo "‚ùå Prometheus CRDs NOT found after 3 minutes!"
            echo "Available CRDs:"
            kubectl get crd | grep -i prometheus || echo "No prometheus CRDs found"
            kubectl get crd | head -20
            exit 1
          fi
          
          # Wait for Grafana CRDs (up to 3 minutes)
          echo "Waiting for Grafana CRDs..."
          for i in {1..90}; do
          if kubectl get crd grafanas.grafana.integreatly.org 2>/dev/null; then
              echo "‚úÖ Grafana CRDs available"
              break
            fi
            echo "  [$i/90] Still waiting for Grafana CRDs..."
            sleep 2
          done
          
          if ! kubectl get crd grafanas.grafana.integreatly.org &>/dev/null; then
            echo "‚ùå Grafana CRDs NOT found after 3 minutes!"
            echo "Available CRDs:"
            kubectl get crd | grep -i grafana || echo "No grafana CRDs found"
            kubectl get crd | head -20
            # Check if Grafana operator is actually installed
            echo "Checking Grafana operator pods:"
            kubectl get pods -n monitoring -o wide 2>/dev/null || echo "monitoring namespace not found"
            exit 1
          fi
          
          # Wait for Kafka CRDs (up to 2 minutes)
          echo "Waiting for Kafka CRDs..."
          for i in {1..60}; do
            if kubectl get crd kafkas.kafka.strimzi.io &>/dev/null; then
              echo "‚úÖ Kafka CRDs available"
              break
            fi
            echo "  [$i/60] Still waiting for Kafka CRDs..."
            sleep 2
          done
          
          if ! kubectl get crd kafkas.kafka.strimzi.io &>/dev/null; then
            echo "‚ùå Kafka CRDs NOT found after 2 minutes!"
            exit 1
          fi
          
          echo ""
          echo "‚úÖ All required CRDs are available, proceeding with resource deployment"
          
          echo "üå± Bootstrapping ArgoCD from Config Repo (${{ inputs.environment }})..."
          # Apply the environment-specific overlay which contains the ArgoCD CR
          kubectl apply -k config/overlays/${{ inputs.environment }}

      - name: Verify ArgoCD Instance
        run: |
          echo "‚è≥ Waiting for ArgoCD Server deployment creation..."
          # Wait for the operator to create the deployment (async operation)
          for i in {1..60}; do
            if kubectl get deployment/trading-argocd-server -n argocd &> /dev/null; then
              echo "‚úÖ Deployment found!"
              break
            fi
            echo "Waiting for deployment creation... ($i/60)"
            sleep 2
          done

          echo "‚è≥ Waiting for ArgoCD Server (trading-argocd-server)..."
          # The operator creates resources with the CR name as prefix
          kubectl wait --for=condition=available deployment/trading-argocd-server -n argocd --timeout=300s
          kubectl wait --for=condition=available deployment/trading-argocd-repo-server -n argocd --timeout=300s
          
          echo "‚úÖ ArgoCD is UP!"
          kubectl get pods -n argocd

      - name: Set ArgoCD Admin Password
        env:
          ARGOCD_ADMIN_PASSWORD: ${{ secrets.argocd_admin_password }}
        run: |
          if [ -z "$ARGOCD_ADMIN_PASSWORD" ]; then
            echo "No admin password provided. Skipping."
            exit 0
          fi

          echo "üîê Updating ArgoCD admin password..."
          pip install bcrypt
          
          # Generate bcrypt hash
          HASH=$(python3 -c 'import bcrypt, os; print(bcrypt.hashpw(os.environ["ARGOCD_ADMIN_PASSWORD"].encode(), bcrypt.gensalt()).decode())')
          
          # Patch the secret using stringData (automatically base64 encodes)
          # The secret name is <cr-name>-cluster -> trading-argocd-cluster
          kubectl patch secret trading-argocd-cluster -n argocd --type=merge -p "{\"stringData\": {\"admin.password\": \"$HASH\"}}"
          
          echo "‚úÖ Password updated. Restarting ArgoCD server..."
          kubectl rollout restart deployment/trading-argocd-server -n argocd

      - name: Debug on Failure
        if: failure()
        run: |
          echo "‚ùå ArgoCD Deployment Failed. Dumping Diagnostic State..."
          echo ""
          echo "::group::üìã Kustomize Build Validation"
          echo "Checking if config overlays are valid..."
          for overlay in dev prod; do
            echo ""
            echo "--- Validating overlay: $overlay ---"
            if [ -d "config/overlays/$overlay" ]; then
              echo "Building Kustomize for: overlays/$overlay"
              kubectl kustomize config/overlays/$overlay > /tmp/kustomize-build-$overlay.yaml 2>&1 || {
                echo "‚ùå Kustomize build failed for $overlay"
                echo "Output:"
                cat /tmp/kustomize-build-$overlay.yaml
              }
            else
              echo "‚ö†Ô∏è  Directory config/overlays/$overlay does not exist"
            fi
          done
          echo "::endgroup::"
          
          echo "::group::üìÅ Config Repository Structure"
          echo "Checking config repo structure..."
          find config -type f -name "*.yaml" | head -30
          echo ""
          echo "Monitoring folder contents:"
          ls -la config/base/monitoring/ 2>/dev/null || echo "‚ö†Ô∏è  monitoring folder not found"
          echo ""
          echo "Dev monitoring overlay contents:"
          ls -la config/overlays/dev/monitoring/ 2>/dev/null || echo "‚ö†Ô∏è  dev/monitoring overlay not found"
          echo "::endgroup::"
          
          echo "::group::üîç Kustomization Files"
          echo "Base monitoring kustomization.yaml:"
          cat config/base/monitoring/kustomization.yaml 2>/dev/null || echo "Not found"
          echo ""
          echo "Dev monitoring kustomization.yaml:"
          cat config/overlays/dev/monitoring/kustomization.yaml 2>/dev/null || echo "Not found"
          echo ""
          echo "Dev root kustomization.yaml:"
          cat config/overlays/dev/kustomization.yaml 2>/dev/null || echo "Not found"
          echo "::endgroup::"
          
          echo "::group::üìù Grafana Patch Files"
          echo "Dev grafana-patch.yaml:"
          cat config/overlays/dev/monitoring/grafana-patch.yaml 2>/dev/null || echo "Not found"
          echo ""
          echo "Prod grafana-patch.yaml:"
          cat config/overlays/prod/monitoring/grafana-patch.yaml 2>/dev/null || echo "Not found"
          echo "::endgroup::"
          
          echo "::group::üèóÔ∏è ArgoCD Operator State"
          kubectl get pods -n argocd-operator-system -o wide || true
          echo ""
          echo "Operator controller logs:"
          kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=100 || true
          echo "::endgroup::"
          
          echo "::group::üì¶ ArgoCD Instance State"
          kubectl get pods -n argocd -o wide || true
          echo ""
          echo "ArgoCD Resources:"
          kubectl get argocd,applications -n argocd -o wide || true
          echo "::endgroup::"
          
          echo "::group::üìä ArgoCD Events & Errors"
          echo "Recent events in argocd namespace:"
          kubectl get events -n argocd --sort-by='.lastTimestamp' --all-namespaces=false | tail -20 || true
          echo ""
          echo "ArgoCD server logs:"
          kubectl logs -n argocd -l app.kubernetes.io/name=trading-argocd-server --tail=100 2>/dev/null || echo "Logs not available yet"
          echo "::endgroup::"
          
          echo "::group::üîê Application Status"
          echo "Checking ArgoCD Applications:"
          kubectl get applications -n argocd -o wide 2>/dev/null || echo "No applications yet"
          echo ""
          echo "Monitoring application details:"
          kubectl describe application monitoring -n argocd 2>/dev/null || echo "Monitoring app not found"
          echo "::endgroup::"
          
          echo ""
          echo "üí° DEBUGGING TIPS:"
          echo "1. Check kustomize build output above for invalid resource references"
          echo "2. Verify all patch files have 'namespace' field specified"
          echo "3. Check patch metadata (name, namespace) matches base resources"
          echo "4. Review ArgoCD operator logs for CRD validation errors"
          echo "5. Ensure all referenced resources exist in base/ before patching"

