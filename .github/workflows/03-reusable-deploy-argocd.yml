name: '03 Reusable: Deploy ArgoCD'

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy (dev or prod)'
        required: true
        type: string
      control_plane_ip:
        description: 'Control Plane IP'
        required: true
        type: string
      kafka_public_ip:
        description: 'Public IP of Kafka Node'
        required: true
        type: string
    secrets:
      ssh_private_key:
        description: 'SSH private key for server access'
        required: true
      token_git_repo_config:
        description: 'Token for config repo access'
        required: true
      ghcr_token:
        description: 'GitHub Container Registry token for pulling private images'
        required: true
      argocd_admin_password:
        description: 'Admin password for ArgoCD'
        required: false

jobs:
  deploy-argocd:
    name: Install ArgoCD Operator
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ssh_private_key }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Download Kubeconfig
        run: |
          CONTROL_IP="${{ inputs.control_plane_ip }}"
          mkdir -p ~/.kube
          
          echo "üì• Downloading kubeconfig from $CONTROL_IP..."
          # Retry loop for robustness
          for i in {1..5}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$CONTROL_IP "cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config 2>/dev/null; then
              sed -i "s/127.0.0.1/$CONTROL_IP/g" ~/.kube/config
              chmod 600 ~/.kube/config
              echo "‚úÖ Kubeconfig downloaded"
              break
            fi
            echo "‚ö†Ô∏è Retry $i/5..."
            sleep 5
          done

      - name: Install ArgoCD Operator
        run: |
          echo "üì¶ Installing ArgoCD Operator..."
          # Install ArgoCD Operator (Non-OLM)
          # Use server-side apply to avoid "metadata.annotations: Too long" error for CRDs
          kubectl apply --server-side -k https://github.com/argoproj-labs/argocd-operator/config/default?ref=v0.15.0-1
          
          echo "‚è≥ Waiting for Operator..."
          kubectl wait --for=condition=available deployment/argocd-operator-controller-manager -n argocd-operator-system --timeout=300s

      - name: Checkout Config Repo
        uses: actions/checkout@v4
        with:
          repository: trading-cz/config
          path: config
          token: ${{ secrets.token_git_repo_config }}

      - name: Bootstrap ArgoCD Instance
        run: |
          echo "üöÄ Creating ArgoCD Namespace..."
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

          echo "üîê Creating GHCR pull secret for ingestion-alpaca namespace..."
          kubectl create namespace ingestion-alpaca --dry-run=client -o yaml | kubectl apply -f -
          kubectl create secret docker-registry ghcr-secret \
            --namespace=ingestion-alpaca \
            --docker-server=ghcr.io \
            --docker-username=trading-cz \
            --docker-password=${{ secrets.ghcr_token }} \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "üîß Patching Kafka Config with Public IP..."
          # We need to inject the real Public IP into the Kafka CR before applying it
          # This is a simple text replacement in the checked-out config
          KAFKA_IP="${{ inputs.kafka_public_ip }}"
          sed -i "s/advertisedHost: .*/advertisedHost: $KAFKA_IP/" config/base/kafka/kafka.yaml
          
          echo "‚è≥ Waiting for Operator CRDs (Prometheus, Grafana, Strimzi)..."
          # Wait for CRDs to be available before applying resources
          # Prometheus Operator CRDs
          timeout 120 sh -c 'until kubectl get crd prometheuses.monitoring.coreos.com 2>/dev/null; do echo "waiting for Prometheus CRD..."; sleep 2; done' || {
            echo "‚ö†Ô∏è  Prometheus CRDs not ready, continuing anyway..."
          }
          # Grafana Operator CRDs
          timeout 120 sh -c 'until kubectl get crd grafanas.grafana.integreatly.com 2>/dev/null; do echo "waiting for Grafana CRD..."; sleep 2; done' || {
            echo "‚ö†Ô∏è  Grafana CRDs not ready, continuing anyway..."
          }
          # Strimzi Kafka CRDs (should already exist from control plane)
          timeout 60 sh -c 'until kubectl get crd kafkas.kafka.strimzi.io 2>/dev/null; do echo "waiting for Kafka CRD..."; sleep 2; done' || {
            echo "‚ö†Ô∏è  Kafka CRDs not ready, continuing anyway..."
          }
          echo "‚úÖ CRD check complete (may still be installing)"
          
          echo "üå± Bootstrapping ArgoCD from Config Repo (${{ inputs.environment }})..."
          # Apply the environment-specific overlay which contains the ArgoCD CR
          kubectl apply -k config/overlays/${{ inputs.environment }}

      - name: Verify ArgoCD Instance
        run: |
          echo "‚è≥ Waiting for ArgoCD Server deployment creation..."
          # Wait for the operator to create the deployment (async operation)
          for i in {1..60}; do
            if kubectl get deployment/trading-argocd-server -n argocd &> /dev/null; then
              echo "‚úÖ Deployment found!"
              break
            fi
            echo "Waiting for deployment creation... ($i/60)"
            sleep 2
          done

          echo "‚è≥ Waiting for ArgoCD Server (trading-argocd-server)..."
          # The operator creates resources with the CR name as prefix
          kubectl wait --for=condition=available deployment/trading-argocd-server -n argocd --timeout=300s
          kubectl wait --for=condition=available deployment/trading-argocd-repo-server -n argocd --timeout=300s
          
          echo "‚úÖ ArgoCD is UP!"
          kubectl get pods -n argocd

      - name: Set ArgoCD Admin Password
        env:
          ARGOCD_ADMIN_PASSWORD: ${{ secrets.argocd_admin_password }}
        run: |
          if [ -z "$ARGOCD_ADMIN_PASSWORD" ]; then
            echo "No admin password provided. Skipping."
            exit 0
          fi

          echo "üîê Updating ArgoCD admin password..."
          pip install bcrypt
          
          # Generate bcrypt hash
          HASH=$(python3 -c 'import bcrypt, os; print(bcrypt.hashpw(os.environ["ARGOCD_ADMIN_PASSWORD"].encode(), bcrypt.gensalt()).decode())')
          
          # Patch the secret using stringData (automatically base64 encodes)
          # The secret name is <cr-name>-cluster -> trading-argocd-cluster
          kubectl patch secret trading-argocd-cluster -n argocd --type=merge -p "{\"stringData\": {\"admin.password\": \"$HASH\"}}"
          
          echo "‚úÖ Password updated. Restarting ArgoCD server..."
          kubectl rollout restart deployment/trading-argocd-server -n argocd

      - name: Debug on Failure
        if: failure()
        run: |
          echo "‚ùå ArgoCD Deployment Failed. Dumping Diagnostic State..."
          echo ""
          echo "::group::üìã Kustomize Build Validation"
          echo "Checking if config overlays are valid..."
          for overlay in dev prod; do
            echo ""
            echo "--- Validating overlay: $overlay ---"
            if [ -d "config/overlays/$overlay" ]; then
              echo "Building Kustomize for: overlays/$overlay"
              kubectl kustomize config/overlays/$overlay > /tmp/kustomize-build-$overlay.yaml 2>&1 || {
                echo "‚ùå Kustomize build failed for $overlay"
                echo "Output:"
                cat /tmp/kustomize-build-$overlay.yaml
              }
            else
              echo "‚ö†Ô∏è  Directory config/overlays/$overlay does not exist"
            fi
          done
          echo "::endgroup::"
          
          echo "::group::üìÅ Config Repository Structure"
          echo "Checking config repo structure..."
          find config -type f -name "*.yaml" | head -30
          echo ""
          echo "Monitoring folder contents:"
          ls -la config/base/monitoring/ 2>/dev/null || echo "‚ö†Ô∏è  monitoring folder not found"
          echo ""
          echo "Dev monitoring overlay contents:"
          ls -la config/overlays/dev/monitoring/ 2>/dev/null || echo "‚ö†Ô∏è  dev/monitoring overlay not found"
          echo "::endgroup::"
          
          echo "::group::üîç Kustomization Files"
          echo "Base monitoring kustomization.yaml:"
          cat config/base/monitoring/kustomization.yaml 2>/dev/null || echo "Not found"
          echo ""
          echo "Dev monitoring kustomization.yaml:"
          cat config/overlays/dev/monitoring/kustomization.yaml 2>/dev/null || echo "Not found"
          echo ""
          echo "Dev root kustomization.yaml:"
          cat config/overlays/dev/kustomization.yaml 2>/dev/null || echo "Not found"
          echo "::endgroup::"
          
          echo "::group::üìù Grafana Patch Files"
          echo "Dev grafana-patch.yaml:"
          cat config/overlays/dev/monitoring/grafana-patch.yaml 2>/dev/null || echo "Not found"
          echo ""
          echo "Prod grafana-patch.yaml:"
          cat config/overlays/prod/monitoring/grafana-patch.yaml 2>/dev/null || echo "Not found"
          echo "::endgroup::"
          
          echo "::group::üèóÔ∏è ArgoCD Operator State"
          kubectl get pods -n argocd-operator-system -o wide || true
          echo ""
          echo "Operator controller logs:"
          kubectl logs -n argocd-operator-system -l control-plane=controller-manager --tail=100 || true
          echo "::endgroup::"
          
          echo "::group::üì¶ ArgoCD Instance State"
          kubectl get pods -n argocd -o wide || true
          echo ""
          echo "ArgoCD Resources:"
          kubectl get argocd,applications -n argocd -o wide || true
          echo "::endgroup::"
          
          echo "::group::üìä ArgoCD Events & Errors"
          echo "Recent events in argocd namespace:"
          kubectl get events -n argocd --sort-by='.lastTimestamp' --all-namespaces=false | tail -20 || true
          echo ""
          echo "ArgoCD server logs:"
          kubectl logs -n argocd -l app.kubernetes.io/name=trading-argocd-server --tail=100 2>/dev/null || echo "Logs not available yet"
          echo "::endgroup::"
          
          echo "::group::üîê Application Status"
          echo "Checking ArgoCD Applications:"
          kubectl get applications -n argocd -o wide 2>/dev/null || echo "No applications yet"
          echo ""
          echo "Monitoring application details:"
          kubectl describe application monitoring -n argocd 2>/dev/null || echo "Monitoring app not found"
          echo "::endgroup::"
          
          echo ""
          echo "üí° DEBUGGING TIPS:"
          echo "1. Check kustomize build output above for invalid resource references"
          echo "2. Verify all patch files have 'namespace' field specified"
          echo "3. Check patch metadata (name, namespace) matches base resources"
          echo "4. Review ArgoCD operator logs for CRD validation errors"
          echo "5. Ensure all referenced resources exist in base/ before patching"

